<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[lolmaus blog]]></title><description><![CDATA[Personal blog of Andrey Mikhaylov (lolmaus), a frontend developer and EmberJS enthusiast]]></description><link>http://lolma.us/ru</link><image><url>https://pbs.twimg.com/profile_images/458644904189501440/ANprYN38.jpeg</url><title>lolmaus blog</title><link>http://lolma.us/ru</link></image><generator>RSS for Node</generator><lastBuildDate>Sat, 06 Jan 2018 13:17:39 GMT</lastBuildDate><atom:link href="http://lolma.us/rss_ru.xml" rel="self" type="application/rss+xml"/><language><![CDATA[ru]]></language><category><![CDATA[ember]]></category><category><![CDATA[emberjs]]></category><category><![CDATA[development]]></category><category><![CDATA[web development]]></category><category><![CDATA[html]]></category><category><![CDATA[css]]></category><category><![CDATA[javascript]]></category><category><![CDATA[js]]></category><category><![CDATA[es2015]]></category><category><![CDATA[programming]]></category><item><title><![CDATA[Делаем динамические binding'и HTML-классов и атрибутов из родительского шаблона]]></title><description><![CDATA[<p>Стандартный способ применить динамические binding'и классов и атрибутов к компоненту ­— это определить их в классе компонента. Для встроенных и аддоновых компонентов для этого потребуется переопределять классы, чего часто делать не хочется. Хотелось бы просто передать binding'и из родительского шаблона без переопределения классов, но это работает не так, как вы думаете.</p><div class="exclamation"></div>
<blockquote>
  <p>Это перевод моей статьи, которую я изначально опубликовал в блоге компании Deveo. Когда она была поглощена компанией Perforce, ее блог был закрыт.</p>
</blockquote>
<p>Каждый Ember-разработчик делал это много раз:</p>
<pre><code class="js language-js">Ember.Component.extend({
  validationResult: Ember.computed(/*...*/),
  classNameBindings: ['validationResult:is-valid:is-invalid']
})</code></pre>
<p>Ember применит к компоненту класс <code>is-valid</code> либо <code>is-invalid</code>, в зависиости от значения свойства <code>validationResult</code>.</p>
<p>В данном случае, свойство <code>validationResult</code> должно быть объявлено на самом компоненте. А где же еще, спросите вы?</p>
<h2 id="пробуем-передать-classnamebindings-из-родительского-шаблона">Пробуем передать <code>classNameBindings</code> из родительского шаблона</h2>
<p>Желание передать <code>classNameBindings</code> из родительского шаблона может возникнуть в том случае, если вам нужно применить динамический класс к компоненту, написанному не вами (встроенному в Ember или происходящему из аддона), и вам не хочется переопределять класс только ради этого.</p>
<p>Моя интуиция подсказывает мне сделать так, но это <strong>не заработает</strong>:</p>
<pre><code class="handlebars language-handlebars">{{textarea
  validationResult  = (gte myText.length 100),
  classNameBindings = 'validationResult:is-valid:is-invalid'
}}</code></pre>
<h2 id="что-происходит">Что происходит</h2>
<p><code>classNameBindings</code> работает на основе устаревшего механизма binding'ов, который задокументирован <a href="http://emberjs.com/api/classes/Ember.Binding.html">тут</a> и будет удален в Ember 3.</p>
<p>Историчеки, binding'и в Ember создавались при помощи этого низкоуровневого API. Затем ему на смену пришел удобный высокоуровневый API, которым мы пользуемся сейчас, и вместо <code>myPropBinding='foo'</code> мы пишем просто <code>myProp=foo</code>. Обратите внимание, что в первом случае название свойства передается в кавычках.</p>
<p>Упрощая нюансы, этот код:</p>
<pre><code class="handlebars language-handlebars">{{textarea
  classNameBindings = 'validationResult:is-valid:is-invalid'
}}</code></pre>
<p>примерно эквивалентен этому:</p>
<pre><code class="handlebars language-handlebars">{{textarea
  classNames = (if validationResult 'is-valid' 'is-invalid')
}}</code></pre>
<p>Но если вы попытаетесь сделать так, как показано в последнем примере, binding не будет динамическим. HTML-класс корректно примет исходное значение, но при изменении <code>validationResult</code> обновляться не будет.</p>
<p>Для решения этой проблемы и нужны <code>classNameBinding</code></p>
<h2 id="как-правильно-использовать-classnamebindings-на-примере-компонента-textarea-без-его-переопределения">Как правильно использовать <code>classNameBindings</code> на примере компонента <code>{{textarea}}</code> без его переопределения</h2>
<p>Свойство, которое вы указываете в <code>classNameBindings</code> в родительском шаблоне, должно быть объявлено в родительском компоненте/контроллере:</p>
<pre><code class="js language-js">// app/components/parent-component.js
Ember.Component.extend({
  name: 'Mike',
  validationResult: Ember.computed.gte('name.length', 100),
})</code></pre>
<pre><code class="handlebars language-handlebars">{{! app/components/parent-component.hbs }}

{{textarea
  classNameBindings = 'validationResult:is-valid:is-invalid'
}}</code></pre>
<p>Очень важно понимать, чем этот пример отличается от самого первого примера статьи. На первый взгляд, они одинаковы, но это не так.</p>
<ul>
<li><p>В первом примере статьи <code>classNameBindings</code> объявлен в классе дочернего компонента и ищет свойства в контексте дочернего компонента.</p></li>
<li><p>А в данном примере, <code>classNameBindings</code> хоть и передается в дочерний компонент, но прописан в родительском шаблоне и ищет свойства в родительском контексте!</p></li>
</ul>
<h2 id="прописать-несколько-свойств-в-classnamebindings-из-родительского-шаблона-невозможно">Прописать несколько свойств в <code>classNameBindings</code> из родительского шаблона невозможно</h2>
<p>Согласно <a href="https://emberjs.com/api/ember/2.18/classes/Component/properties/classNameBindings?anchor=classNameBindings">документации компонента</a>, свойство <code>classNameBindings</code> должно содержать массив.</p>
<p>Я предполагал, что это сработает, но оно не работает:</p>
<pre><code class="handlebars language-handlebars">{{textarea
  classNameBindings = (array 'validationResult:is-valid:is-invalid')
}}</code></pre>
<p>Я не нашел способа передать больше одного свойства в <code>classNameBindings</code>. Для этого все-таки требуется (пере)определять класс компонента и прописывать <code>classNameBindings</code> в нем.</p>
<p>К счастью, есть способ лучше.</p>
<h2 id="используйте-class-вместо-classnamebindings-в-родительском-шаблоне">Используйте class вместо classNameBindings в родительском шаблоне!</h2>
<p>Свойство <code>class</code>, недоступное при объявлении класса компонента, можно передавать в компонент из родительского шаблона. И в нем можно передавать несколько binding'ов!</p>
<p>Вы наверняка делали это много раз:</p>
<pre><code class="handlebars language-handlebars">&lt;div class = "foo {{bar}} {{if baz 'quux' 'zomg'}}"&gt;</code></pre>
<p>При передаче <code>class</code> потребуется конкатенация:</p>
<pre><code class="handlebars language-handlebars">{{my-component
  class = (concat 'foo ' bar (if baz ' quux' ' zomg'))
}}</code></pre>
<p>Обратите внимание на дополнительные пробелы в строковых литералах.</p>
<h2 id="что-насчет-attributebindings">Что насчет attributeBindings?</h2>
<p>Ember (Glimmer?) запрещет передавать <code>attributeBindings</code> из родительского шаблона. Такая запись сломает ваше приложение:</p>
<pre><code class="handlebars language-handlebars">{{my-component
  attributeBindings = "foo"
}}</code></pre>
<p>Некоторые Ember-аддоны используют mixin, который bind'ит все переданные извне свойства на HTML-атрибуты. С помощью такого mixin'а можно делать так:</p>
<pre><code class="handlebars language-handlebars">{{my-component
  disabled = isDisabled
  data-foo = "bar"
}}</code></pre>
<p>К примеру, вот как выглядит приватный mixin <code>dynamic-attribute-bindings</code> аддона <code>ember-one-way-controls</code> [<a href="https://github.com/DockYard/ember-one-way-controls/blob/v3.0.1/addon/-private/dynamic-attribute-bindings.js](uses">https://github.com/DockYard/ember-one-way-controls/blob/v3.0.1/addon/-private/dynamic-attribute-bindings.js](uses</a> internally):</p>
<pre><code class="js language-js">// https://github.com/DockYard/ember-one-way-controls/blob/v3.0.1/addon/-private/dynamic-attribute-bindings.js
import Ember from 'ember';

const { Mixin, set } = Ember;

export default Mixin.create({
  NON_ATTRIBUTE_BOUND_PROPS: ['class', 'classNames'],
  concatenatedProperties: ['NON_ATTRIBUTE_BOUND_PROPS'],
  init() {
    this._super(...arguments);

    let newAttributeBindings = [];
    for (let key in this.attrs) {
      if (this.NON_ATTRIBUTE_BOUND_PROPS.indexOf(key) === -1 &amp;&amp; this.attributeBindings.indexOf(key) === -1) {
        newAttributeBindings.push(key);
      }
    }

    set(this, 'attributeBindings', this.attributeBindings.concat(newAttributeBindings));
  }
});</code></pre>
<p>Обратите внимание, что этот mixin использует черный список. Все свойства, которые не упомянуты в <code>NON_ATTRIBUTE_BOUND_PROPS</code>, будут за'bind'ены на HTML-атрибуты. Свойство NON_ATTRIBUTE_BOUND_PROPS помечено как concatenated, т. е. если вы  его переопределите, то вместо переопределения произойдет пополнение массива, содержащегося в свойстве.</p>
<p>Вы можете изменить эту логику под свои задачи, например, применив белый список вместо черного.</p>
<h2 id="знаете-больше-поделитесь">Знаете больше? Поделитесь!</h2>
<p>Выражаю благодарность Ricardo Mendes (<a href="https://github.com/locks">@locks</a>) за терпеливые разъяснения о том, как работает <code>classNameBindings</code>.</p>
<p>Если вы увидите неточность в статье или можете лучше объяснить, что происходит с binding'ами классов и атрибутов, обязательно поделитесь в комментариях!</p>]]></description><link>http://lolma.us/ru/blog/class-and-attribute-bindings</link><guid isPermaLink="true">http://lolma.us/ru/blog/class-and-attribute-bindings</guid><pubDate>Sat, 06 Jan 2018 00:00:00 GMT</pubDate></item><item><title><![CDATA[Теперь я работаю в Deveo!]]></title><description><![CDATA[<p>Мне всегда хотелось разрабатывать продукт от разработчиков для разработчиков.</p><p><a href="https://deveo.com">Deveo.com</a> — это сервис, предоставляющий приватные репозитории Git, SVN и Mercurial.</p>
<p><a href="https://deveo.com/about/">Команда</a> Deveo — просто замечательная, работать с этими парнями настоящее удовольствие.</p>
<p>Вот мой <a href="http://blog.deveo.com/andrey-mikhaylov-lolmaus-has-joined-deveo/">приветственный пост</a> в официальном блоге Deveo.</p>
<p>Представьте себе, мое первое задание ­ это open source проект: аддон <a href="https://github.com/Deveo/ember-emojione">ember-emojione</a>. Скоро вы сможете прочитать о нем больше.</p>]]></description><link>http://lolma.us/ru/blog/deveo</link><guid isPermaLink="true">http://lolma.us/ru/blog/deveo</guid><pubDate>Tue, 07 Feb 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Не путайте environment с deploy target]]></title><description><![CDATA[<p>У большинства фрэймворков есть понятие <em>environment</em>. Многие разработчики привязывают к environment параметры развертывания, что неверно.</p><p>Недавно я в очередной раз наткнулся на эту проблему и решил написать о ней данную заметку. Пишу с оглядкой на фронтенд-фрэймворк <strong>EmberJS</strong>, но суть применима к любому фронтенд- и бэкенд-фрйэмворку.</p>
<h2 id="термин-environment-слишком-размыт">Термин environment слишком размыт</h2>
<p>Термин <strong>environment</strong> применяется очень широко, что вызывает путаницу. В интернете есть много статей, которые, если прочитать их поверхностно, противоречат тому, что я хочу посоветовать ниже. Долгое время эти статьи вызывали у меня недоумение. Пораскинув мозгами, я понял, что дело в путаной терминологии.</p>
<p>В <strong>EmberJS</strong> и многих других вэб-фрэймворках понятие <strong>environment</strong> применяется в достаточно узком смысле, и я далее буду придеживаться именно его. <strong>Environment</strong> — это набор параметров, конфигурирующих сборку и запуск вэб-приложения:</p>
<ul>
<li>минификация кода,</li>
<li>asset fingerprinting/cache busting,</li>
<li>генерация source maps,</li>
<li>внедрение различных средств, облегчающих отладку,</li>
<li>тестирование,</li>
<li>внедрение маркеров для оценки покрытия кода,</li>
<li>удаление тестировочных селекторов из HTML.</li>
</ul>
<p>Но есть и другая группа параметров, которую также принято включать в понятие <strong>environment</strong>. Я считаю, что это большая ошибка, и предлагаю отличать две группы. Вторую группу параметров я называю <strong>deploy target</strong>:</p>
<ul>
<li>адреса API,</li>
<li>адреса CDN,</li>
<li>настройки CSP (content security policy) и CORS (cross-origin resource sharing),</li>
<li>ключи API.</li>
</ul>
<h2 id="в-чем-собственно-проблема">В чем, собственно, проблема</h2>
<p>Многие разработчики сваливают обе группы параметров в одну кучу и привязывают к параметру <strong>environment</strong>, который у большинства фрэймворков может принимать всего три значения: <code>development</code>, <code>production</code> и <code>test</code>.</p>
<p>В результате приложение по сути имеет всего два режима сборки: production-билд, привязанный к production серверу, и development-билд привязанный к локальному серверу или моку (имитации сервера).</p>
<p>Сделать сборку в development-режиме, но привязанную к production серверу, затруднительно: для этого приходится временно редактировать конфиг. А ведь такая сборка может очень выручить, когда нужно отладить пробему, которая проявляется в продакшене, но не воспроизводится локально.</p>
<p>Обратное тоже порой необходимо: сделать сборку для локального сервера, но в production режиме. Это нужно, например, чтобы замерить производительность или чтобы отладить проблему, возникающую во время минификации и фингерпринтинга.</p>
<p>А хуже всего то, что ключи API хранятся прямо в конфиге и попадают в систему контроля версий, что угрожает безопасности вашего сервиса.</p>
<h2 id="как-надо-делать">Как надо делать</h2>
<p>Я рекомендую использовать так называемые <em>dotenv</em>-файлы.</p>
<p>Это конфигурационные файлы, имена которых начинаются с <code>.env-</code>. Они содержат определения переменных окружения в виде пар ключ=значение, по одной на строку:</p>
<pre><code>FOO=bar
BAZ=quux</code></pre>
<p>Ваше приложение будет считывать нужный файл во время сборки и использовать соответствующие настройки.</p>
<p>Переменные окружения по-английски называются <strong>environment variables</strong>, что добавляет путаницы, так что будьте внимательны. Переменные окружения — это такие переменные, которые можно передать из командной строки.</p>
<p>Вот, что вы должны сделать:</p>
<ol>
<li><p>Удалите параметры группы <strong>deploy target</strong> из конфига приложения.</p></li>
<li><p>Вынесите их в dotenv-файлы, по одному для каждого сервера: <code>.env-production</code>, <code>.env-staging</code>, <code>.env-sandbox</code>, <code>.env-local</code>, <code>.env-mock</code> и т. д. Их может быть столько, сколько вам нужно, а не только production и development.</p></li>
<li><p>Обязательно добавьте dotenv-файлы в <code>.gitignore</code>, чтобы ключи API не засветились в системе контроля версий.</p></li>
<li><p>Если вы используете <abbr title="continuous integration">CI</abbr>, содержимое этих файлов можно скопировать в настройки каждого сервера. На CodeShip, например, соответствующий раздел настроек называется "deployment pipelines".</p></li>
<li><p>Настройте приложение так, чтобы при сборке можно было указать, какой <strong>deploy target</strong> использовать. Большинство платформ имеют для этого библиотеку <code>dotenv</code>.</p></li>
</ol>
<p>Теперь <strong>deploy target</strong> можно выбирать отдельно от <strong>environment</strong>, получая любое нужное вам сочетание <strong>deploy target</strong> и <strong>environment</strong>. Например, я это делаю так:</p>
<pre><code>DEPLOY_TARGET=local ember serve --environment=production</code></pre>
<p>Разумеется, для удобства вы можете настроить, чтобы для каждого <strong>environment</strong> автоматически использовался определенный <strong>deploy target</strong>, чтобы не приходилось указывать каждый раз.</p>
<p>Внимательный читатель возразит: круг замкнулся, и <strong>environment</strong> снова опеределяет <strong>deploy target</strong>. За что боролись?</p>
<p>По-умолчанию всё останется как было, но у вас теперь появилась возможность в нужный момент вручную задействовать любое сочетание <strong>environment</strong> и <strong>deploy target</strong> — без необходимости редактировать код, а потом откатывать.</p>
<h2 id="как-использовать-dotenv-в-ember">Как использовать dotenv в Ember</h2>
<p>Npm-библиотека <a href="https://www.npmjs.com/package/dotenv">dotenv</a> может использоваться в Ember напрямую. Однако если вам нужно считывать параметры <strong>deploy target</strong> как в <code>config/environment.js</code>, так и в <code>ember-cli-build.js</code>, либо если вы используете FastBoot, то воспользуйтесь аддоном <a href="https://github.com/fivetanley/ember-cli-dotenv">ember-cli-dotenv</a>.</p>
<p>Создайте в корневой папке вашего Ember-приложения <code>.env</code>-файлы, по одному для каждого вашего сервера, включая локальный и мок-сервер, если вы их используете:</p>
<pre><code>.env-production
.env-staging
.env-sandbox
.env-local
.env-mock</code></pre>
<p>Особенно круто, если у ваших серверов есть имена собственные. В таком случае используйте эти имена в названиях <code>.env</code>-файлов.</p>
<p>В каждом файле храните параметры <strong>deploy target</strong> в таком виде:</p>
<pre><code>MYAPP_BACKEND_API_URL=https://bravo.horns-and-hooves.com/api
MYAPP_BACKEND_API_VERSION=v18
MYAPP_IMAGES_CDN_URL=http://horns-and-hooves.cloudfront.net/bravo/images
MYAPP_GITHUB_API_KEY=jFViG9kZtY4NAJA8I65s</code></pre>
<p><code>MYAPP</code> — это отсылка к названию вашего приложения. Добавлять его полезно, чтобы не переопределить какую-либо внешнюю переменную, которая может потребоваться и навзание которой может совпадать с одним из ваших.</p>
<p>Теперь нам нужно добиться, чтобы <code>ember-cli-dotenv</code> подгружал нужный dotenv-файл. Для этого воспользуйтесь таким трюком в файле <code>config/environment.js</code>:</p>
<pre><code class="javascript language-javascript">const fs = require('fs')

const environment   = process.env.EMBER_ENV || 'development'
const defaultTarget = environment === 'production' ? 'production' : 'localhost-4200'
const target        = process.env.DEPLOY_TARGET || defaultTarget
const dotEnvFile    = `./.env-${target}`

if (fs.existsSync(dotEnvFile)) console.info(`using dotenv file: ${dotEnvFile}`)
else console.warn(`dot-env file not found: ${dotEnvFile}, assuming env vars are passed manually`)



module.exports = function (env) {
  return {
    clientAllowedKeys : [
      'MYAPP_BACKEND_API_URL',
      'MYAPP_BACKEND_API_VERSION',
      'MYAPP_IMAGES_CDN_URL',
      'MYAPP_GITHUB_API_KEY',
    ],
    path : dotEnvFile,
  }
}</code></pre>
<p>Теперь параметры из dotenv-файла попадут в хэш <code>process.env</code>, который вы можете использовать в <code>config/environment.js</code> и <code>ember-cli-build.js</code> следующим образом:</p>
<pre><code class="javascript language-javascript">{
  gitHubApiKey: process.env.MYAPP_GITHUB_API_KEY
}</code></pre>
<div class="exclamation"></div>
<blockquote>
  <p>Рекомендую дополнительно создать в вашем Ember-приложении сервис <code>config</code>, который будет проксировать настройки из <code>config/environment.js</code>. Это дает возможность использовать computed properties для формирования производных параметров, например, добавления версии API в адрес сервера.</p>
</blockquote>
<p>По умолчанию, приведенный выше кгод будет использовать <strong>deploy target</strong> <code>production</code> в <strong>environment</strong> <code>production</code> и <code>localhost-4200</code> в <code>development</code>. Одредактируйте названия <strong>deploy targets</strong>, используемые в коде, чтобы совпали с вашими.</p>
<pre><code> ember s -prod   # использует `production` environment с `production` deploy target
 ember s         # использует `development` environment с `localhost-4200` deploy target</code></pre>
<p>Вы можете указать, какой dotenv-файл использовать:</p>
<pre><code>DEPLOY_TARGET=localhost-4200 ember s -prod   # использует `production` environment с `localhost-4200` deploy target
DEPLOY_TARGET=production ember s             # использует `development` environment с `production` deploy target</code></pre>
<h2 id="в-сочетании-с-ember-cli-deploy">В сочетании с ember-cli-deploy</h2>
<p><code>ember-cli-deploy</code> <a href="http://ember-cli-deploy.com/docs/v1.0.x/using-env-for-secrets/">имеет встроенную поодержку dotenv-файлов</a>, однако они используются только для команд <code>ember deploy</code>, в то время как описанный выше способ подходит не только для <code>ember deploy</code>, но и для <code>ember serve</code>, <code>ember build</code>, <code>ember test</code> и т. п.</p>
<p>При работе с <code>ember-cli-deploy</code> стоит обратить внимание на несколько нюансов.</p>
<p>Во-первых, документация <code>ember-cli-deploy</code> использует словосочетание "build environment" в качестве синонима <strong>deploy target</strong>, что добавляет путаницы.</p>
<p>Во-вторых, в конфиге <code>config/deploy.js</code> можно настраивать параметры сборки в зависимости от <strong>deploy target</strong>. Обязательно переименуйте <strong>deploy targets</strong> в этом файле, приведя их в соответствие названиям ваших dotenv-файлов.</p>
<p>В-третьих, не используйте сокращения <code>dev</code> и <code>prod</code> вместо <code>development</code> и <code>production</code>. </p>
<p>В-четвертых, обратите внимание, что <code>ember-cli-deploy</code> также применяет переменную окружения <code>DEPLOY_TARGET</code>. Однако она почему-то не используется для конфигурации из командной строки.</p>
<p>Использовать ее так нельзя:</p>
<pre><code>DEPLOY_TARGET=production ember deploy</code></pre>
<p>Вместо этого предлагается писать</p>
<pre><code>ember deploy production</code></pre>
<p>Зачем же в <code>ember-cli-deploy</code> вообще нужна переменная окружения <code>DEPLOY_TARGET</code>? Если у вас возникнет необходимость определить <strong>deploy target</strong> в файле <code>ember-cli-build.js</code>, то вы можете обратится к ней так: <code>process.env.DEPLOY_TARGET</code>.</p>
<p>Беда в том, что файл <code>config/dotenv.js</code> отрабатывает раньше, чем команда <code>ember deploy production</code> переключает <strong>environment</strong> в <code>production</code> и присваивает значение переменной <code>DEPLOY_TARGET</code>. </p>
<p>Выйти из положения можно, указывая <code>DEPLOY_TARGET</code> явно, чтобы <code>config/dotenv.js</code> использовал именно его.</p>
<pre><code>DEPLOY_TARGET=production ember deploy production</code></pre>
<p>Но команда получается достаточно громоздкой. Избежать избыточности можно, научив ваш <code>config/dotenv.js</code> замечать команду <code>ember deploy production</code>:</p>
<pre><code class="js language-js">const fs = require('fs')

function getDeployTarget () {
  return process.env.DEPLOY_TARGET || getDefaultDeployTarget()
}

function getDefaultDeployTarget () {
  const environment =
    process.env.EMBER_ENV
    || deployEnv()
    || 'development'

  return environment === 'production' ? 'production' : 'localhost-4200'
}

function deployEnv () {
  if (process.argv[2] === 'deploy' &amp;&amp; process.argv[3] === 'prod') {
    throw new Error("Command `ember deploy prod` is not supported. Please use `ember deploy production`.")
  } else if (process.argv[2] === 'deploy' &amp;&amp; process.argv[3] === 'production') {
    return 'production'
  }
}



const dotEnvFile   = `./.env-${getDeployTarget()}`

if (fs.existsSync(dotEnvFile)) console.info(`Using dotenv file: ${dotEnvFile}`)
else console.warn(`dot-env file not found: ${dotEnvFile}, assuming env vars are passed manually`)



module.exports = function (env) {
  return {
    clientAllowedKeys : [
      'MYAPP_BACKEND_API_URL',
      'MYAPP_BACKEND_API_VERSION',
      'MYAPP_IMAGES_CDN_URL',
      'MYAPP_GITHUB_API_KEY',
    ],
    path : dotEnvFile,
  }
}</code></pre>
<p>В результате команда <code>ember deploy production</code> задействует dotenv-файл <code>.env-production</code> и переключит <strong>environment</strong> в <code>production</code>.</p>
<p>Если же вам понадобиться залить на production-сервер сборку без минификации, то вы можете воспользоваться командой:</p>
<pre><code>EMBER_ENV=development ember deploy production</code></pre>
<h2 id="ваше-мнение">Ваше мнение?</h2>
<p>Обязательно поделитесь своими соображениями в комментариях!</p>]]></description><link>http://lolma.us/ru/blog/do-not-confuse-env-for-deploy-target</link><guid isPermaLink="true">http://lolma.us/ru/blog/do-not-confuse-env-for-deploy-target</guid><pubDate>Sat, 18 Feb 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Новый сайт!]]></title><description><![CDATA[<p>Я выложил новый сайт! Он выглядит скромно, но напичкан различными фичами и лучшими практиками EmberJS. Он задуман как демонстрация моих навыков.</p><p>Здесь я не буду вдаваться в детали, поскольку в моем <a href="http://lolma.us/ru/">резюме</a> есть целый раздел с описанием сайта. Пожалуйста, взгляните!</p>
<p>Этот сайт обозначает новый этап моего развития. Теперь я со спокойной уверенностью считаю себя senior Ember-разработчиком.</p>]]></description><link>http://lolma.us/ru/blog/new-website</link><guid isPermaLink="true">http://lolma.us/ru/blog/new-website</guid><pubDate>Sun, 04 Dec 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[PromiseProxyMixin: нативная альтернатива ember-concurrency]]></title><description><![CDATA[<p>ember-concurrency — исключительно мощный и полезный аддон. Однако если ваш единственный юз-кейс — это обращаться к серверу, то взгляните на легковесную альтернативу</p><div class="exclamation"></div>
<blockquote>
  <p>Это перевод моей статьи, которую я изначально опубликовал в блоге компании Deveo. Когда она была поглощена компанией Perforce, ее блог был закрыт.</p>
</blockquote>
<p><a href="http://ember-concurrency.com">ember-concurrency</a> — это исключительно мощный и удобный аддон, решающий множество разнообразных задач.</p>
<p>Однако самая типовая задача — просто обращаться к серверу: либо загружать данные, либо передавать. Вы можете посчитать чрезмерным устанавливать <code>ember-concurrency</code> только ради этого.</p>
<p>И будете совершенно правы. В Ember имеются все необходимые примитивы для решения этой задачи в том же стиле, что <code>ember-concurrency</code>: просто, эффективно и в рамках Ember way.</p>
<h2 id="пример-задачи">Пример задачи</h2>
<p>Позвольте продемонстрировать предлагаемый мной подход на простом примере. Мы будем получать с GitHub количество доступных обращений к GitHub API:</p>
<pre><code>GET http://api.github.com/rate_limit</code></pre>
<p>Я выбрал именно этот API endpoint, потому что это единственный endpoint, который GitHub не ограничивает по количеству обращений. :trollface:</p>
<p>Давайте для начала реализуем метод загрузки данных:</p>
<pre><code class="js language-js">import Controller from '@ember/controller'
import fetch from 'fetch'

Controller.extend({
  _fetchGitHubRate () {
    return fetch('https://api.github.com/rate_limit')
      .then(response =&gt; response.json());
  },
});</code></pre>
<p>Я использую аддон <a href="https://github.com/ember-cli/ember-fetch">ember-fetch</a> ради его простоты, но на его месте может быть всё что угодно, что возвращает promise, например, сервис <a href="https://github.com/ember-cli/ember-ajax">ember-ajax</a>.</p>
<p>Метод может находиться не только в контроллере, но и в любой другой сущности Ember: компоненте, сервисе, модели и т. д.</p>
<h2 id="встречайте-promiseproxymixin">Встречайте <code>PromiseProxyMixin</code></h2>
<p>Вы наверняка слышали мнение, что возвращать promise из computed property (CP) — плохая идея. С <a href="https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin">PromiseProxyMixin</a> это не так.</p>
<p>Давайте создадим класс, в который включим <code>PromiseProxyMixin</code>. Это можно сделать на верхнем уровне вашего модуля:</p>
<pre><code class="js language-js">import EmberObject from '@ember/object'
import PromiseProxyMixin from '@ember/object/promise-proxy-mixin'

const PromiseObject = EmberObject.extend(PromiseProxyMixin);</code></pre>
<p>Теперь мы можем обернуть promise в <code>PromiseObject</code>. Обязательно разделите promise и proxy на два отдельных свойства:</p>
<pre><code class="js language-js">// This CP returns a simple promise
gitHubRatePromise: computed(function () {
  return this._fetchGitHubRate();
}),

// This CP wraps the promise with with `PromiseObject` 
gitHubRateProxy: computed('gitHubRatePromise', function () {
  const promise = this.get('gitHubRatePromise');
  return promise &amp;&amp; PromiseObject.create({promise});
}),</code></pre>
<p>Обратите внимание на <code>promise &amp;&amp;</code>. Если promise отсутствует, proxy создаваться не должен, т. к. в этом случае он "упадет" с ошибкой.</p>
<h2 id="обращение-к-содержимому-promiseа">Обращение к содержимому promise'а</h2>
<p>API endpoint, к которому мы обращаемся, возвращает данные в таком формате (фрагмент):</p>
<pre><code class="js language-js">{
  "resources": {
    "core": {
      "limit": 60,
      "remaining": 60,
      "reset": 1486831110
    },
}</code></pre>
<p>Этот хэш будет доступен в шаблоне как <code>gitHubRateProxy.content</code>. Вы можете работать с этим свойством как обычно:</p>
<pre><code class="js language-js">  gitHubRate:          reads('gitHubRateProxy.content'),
  gitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),
  gitHubRateLimit:     reads('gitHubRate.resources.core.limit'),</code></pre>
<p>Пока promise не resolved, эти свойства будут иметь значение <code>undefined</code>. Когда мы будем использовать их в другом computed property, надо защититься от <code>undefined</code>:</p>
<pre><code class="js language-js">  gitHubRatePercentage: computed('gitHubRateRemaining', 'gitHubRateLimit', function () {
    const gitHubRateRemaining = this.get('gitHubRateRemaining');
    const gitHubRateLimit     = this.get('gitHubRateLimit');

    // We don't want a `NaN`!
    if (gitHubRateRemaining == null || gitHubRateLimit == null) return;

    const percentage  = Math.round(gitHubRateRemaining / gitHubRateLimit * 100);

    return `${percentage}%`;
  }),</code></pre>
<p>Применим результат в шаблоне:</p>
<pre><code class="handlebars language-handlebars">Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})</code></pre>
<h2 id="как-это-работает">Как это работает</h2>
<p>Изначально, CP <code>gitHubRatePromise</code> не рассчитано, и обращение к серверу не происходит.</p>
<p>Когда рендерится наш шаблон, происходит считывание свойства <code>gitHubRateRemaining</code>. Это CP зависит от <code>gitHubRateProxy</code>. Тот, в свою очередь, обращается к <code>gitHubRatePromise</code>.</p>
<p>При первом обращении к <code>gitHubRatePromise</code> выполняется метод <code>_fetchGitHubRate</code> и совершается запрос. Метод возвращает promise, который кэшируется в свойстве <code>gitHubRatePromise</code>.</p>
<p>Это означает, что при повторном обращении к свойству будет возвращаться один и тот же promise, и запрос не будет выполняться повторно. По сути, реализуется паттерн <code>drop</code> из <code>ember-concurrency</code>.</p>
<p>Свойство <code>gitHubRateProxy</code> оборачивае promise в proxy <code>PromiseObject</code>. Когда promise отресолвится, его resolve value станет доступно как <code>gitHubRateProxy.content</code>.</p>
<p>Обратите внимание, что данный подход декларативен. Вам не требуется делать этого:</p>
<pre><code class="js language-js">didInsertElement () {
  this._super()
  this.get('fetchGitHubRateTask').perform()
}</code></pre>
<h2 id="учитываем-что-выполнение-promise-занимает-время">Учитываем, что выполнение promise занимает время</h2>
<p>Пока promise не отресолвится, содержимое <code>gitHubRateProxy.content</code> будет <code>undefined</code>. Это означает, что пока запрос выполняется, в шаблоне будет пустота. Давайте это исправим.</p>
<p><code>PromiseProxyMixin</code> предоставляет свойство <code>gitHubRateProxy.isPending</code>. Воспользуемся им в шаблоне:</p>
<pre><code class="handlebars language-handlebars">{{#if gitHubRateProxy.isPending}}

  Retrieving GitHub rate limit...

{{else}}

  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})

{{/if}}</code></pre>
<p>Вполне естественная запись. Выходит, возвращать promise из computed property не так уж плохо! 😉</p>
<h2 id="учитываем-что-запрос-может-завершиться-неудачей">Учитываем, что запрос может завершиться неудачей</h2>
<p>Внимательный четатель мог заметить проблему: если promise будет rejected, например, вследствие сетевого сбоя, то reject'нутое состояние promise'а будет закэшировано навсегда. В этом проявляется одно из преимуществ <code>ember-concurrency</code>: он позволяет без труда перезапустить задачу.</p>
<p>В случае с promise нам понадобиться написать несколько строк кода. Идея в том, чтобы перезаписать computed property <code>gitHubRatePromise</code> обычным, не computed, promise'ом:</p>
<pre><code class="js language-js">  actions: {
    refetchGitHubRate () {
      this.set('gitHubRatePromise', this._fetchGitHubRate());
    }
  },</code></pre>
<p>Вызов этого action'а спровоцирует новый сетевой запрос. Соответствующий promise будет присвоен в свойство <code>gitHubRatePromise</code>, что вызовет пересчет всех свойств, которые от него зависят, и далее по цепочке.</p>
<p>Если promise будет rejected, то свойство <code>gitHubRateProxy.isRejected</code> примет значение <code>true</code>, а rejection value (обычно это объект Error) будет доступно в <code>gitHubRateProxy.reason</code>.</p>
<p>Давайте попробуем:</p>
<pre><code class="handlebars language-handlebars">{{#if gitHubRateProxy.isRejected}}

  Failed to retrieve GitHub rate limit.&lt;br&gt;

  Reason: {{gitHubRateProxy.reason}}&lt;br&gt;

  &lt;a href {{action 'refetchGitHubRate'}}&gt;
    Retry
  &lt;/a&gt;

{{else if gitHubRateProxy.isPending}}

  Retrieving GitHub rate limit...

{{else}}

  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})

{{/if}}</code></pre>
<h2 id="демо">Демо</h2>
<p>Посмотреть полный код примера и попробовать его в деле вы можете <a href="https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs">на Ember Twiddle</a>:</p>
<iframe src="https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?fullScreen=true" style="width: 100%; height: 500px; border: 2px solid biege;"></iframe>
<p><br></p>
<p><a href="https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs">Тут</a> вы найдете аналогичный пример на <code>ember-concurrency</code> для сравнения.</p>
<h2 id="переносим-логику-в-севрис-для-переиспользования">Переносим логику в севрис для переиспользования</h2>
<p>Если вы поместили описанную логику в компонент, который используется в двух разных маршрутах, то при переходе между маршрутами данные будут запрашиваться повторно, поскольку при покидании маршрута компонент уничтожается, а вместе с ним и promise.</p>
<p>Вероятно, предпочтительнее будет не перезапрашивать данные при смене маршрута, а делать это только по запросу. Для этого promise должен кэшироваться глобально и не быть привязан к компоненту.</p>
<p>Очевидное решение — поместить эту логику в сервис. Очень удобно для этого расширять сервис <a href="https://github.com/ember-cli/ember-ajax">ember-ajax</a>.</p>
<h2 id="emberobjectproxy-не-нужен"><code>Ember.ObjectProxy</code> не нужен</h2>
<p><a href="https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin">Официальная документация по PromiseProxyMixin</a> предлагает использовать<code>Ember.ObjectProxy</code> в качестве базвого класса для примешивания <code>PromiseProxyMixin</code>. Однако <code>ObjectProxy</code> применяет кое-какую черную магию, из-за чего я предпочитаю его избегать.</p>
<p>Единственное преимущество <code>ObjectProxy</code> — это сократить этот путь:</p>
<pre><code>gitHubRateProxy.content.resources.core.remaining</code></pre>
<p>до этого:</p>
<pre><code>gitHubRateProxy.resources.core.remaining</code></pre>
<p>Всего лишь пропадает необходимость писать <code>.content</code>. Не такая уж большая польза.</p>
<p>Естественно, эта черная магия не работает с массивами. Для массивов предлагается использовать <code>Ember.ArrayProxy</code>, который в свою очередь не работает с объектами. А если ваш promise возвращает инстанс класса, а не просто хэш, то не подходит ни один из вариантов.</p>
<p><code>Ember.Object</code>, напротив, универсален. Необходимость дописывать <code>.content</code> — это малая цена за прозрачность происходящего. Я думаю, <code>ObjectProxy</code> and <code>ArrayProxy</code> — это пережитки времен давно ушедших  <code>ObjectController</code> и <code>ArrayController</code>.</p>
<h2 id="ember-deferred-content-и-ember-async-button-тоже-не-нужны"><code>ember-deferred-content</code> и <code>ember-async-button</code> тоже не нужны</h2>
<p>Эти два аддона оборачивают promise в proxy на уровне шаблона. Они предлагают своеобразные шаблонные конструкции, не имея никаких преимуществ над <code>PromiseProxyMixin</code>.</p>
<p>Сравните:</p>
<pre><code class="handlebars language-handlebars">{{#if gitHubRateProxy.isRejected}}

  Failed to retrieve GitHub rate limit.&lt;br&gt;

  Reason: {{gitHubRateProxy.reason}}&lt;br&gt;

  &lt;a href {{action 'refetchGitHubRate'}}&gt;
    Retry
  &lt;/a&gt;

{{else if gitHubRateProxy.isPending}}

  Retrieving GitHub rate limit...

{{else}}

  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})

{{/if}}</code></pre>
<pre><code class="handlebars language-handlebars">{{#deferred-content gitHubRatePromise as |d|}}
  {{#d.pending}}
    Retrieving GitHub rate limit...
  {{/d.pending}}

  {{#d.fulfilled as |gitHubRate|}}
    Your GitHub rate limit:

    {{gitHubRate.resources.core.remaining}}

    ({{multiply
      (divide gitHubRate.resources.core.remaining gitHubRate.resources.core.limit)
      100
    }}%)
  {{/d.fulfilled}}

  {{#d.rejected as |reason|}}
    Failed to retrieve GitHub rate limit.&lt;br&gt;

    Reason: {{reason}}&lt;br&gt;

    &lt;a href {{action 'refetchGitHubRate'}}&gt;
      Retry
    &lt;/a&gt;
  {{/d.rejected}}
{{/deferred-content}}</code></pre>
<p>Обратите внимание, что <code>ember-deferred-content</code> вынуждает вас вычислять проценты на уровне шаблона.</p>
<h2 id="я-не-отговариваю-вас-использовать-ember-concurrency">Я не отговариваю вас использовать <code>ember-concurrency</code></h2>
<p>Основная цель этой статьи — показать вам данный прием и заставить немного задуматься. Этот прием весьма практичен, и я часто пользуюсь им в своих проектах, где не используется <code>ember-concurrency</code>.</p>
<p>Отказаться от <code>ember-concurrency</code> в пользу <code>PromiseProxyMixin</code> можно по двум причинам:</p>
<ul>
<li>вы считаете каждый килобайт размера вашего дистрибутива;</li>
<li>вы хотите обойтись без лишних сущностей, слоев и абстракций.</li>
</ul>
<p>Если же вы уже хорошо знакомы с <code>ember-concurrency</code>, и он включен в ваш проект, то использовать <code>PromiseProxyMixin</code> нет смысла. Скорее всего, код на <code>ember-concurrency</code> получится немного короче:</p>
<pre><code class="js language-js">gitHubRateTask: task(function * () {
  return yield this._fetchGitHubRate();
}).restartable().on('didInsertElement')

gitHubRate:          reads('gitHubRateTask.last.value'),
gitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),
gitHubRateLimit:     reads('gitHubRate.resources.core.limit'),

// Если этого не сделать, запрос не будет выполнен. Императивненько. :(
didInsertElement () {
  this._super()
  this.get('fetchGitHubRateTask').perform()
}</code></pre>
<p>Повторяю <a href="https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs">ссылку</a> на пример, выполненный на <code>ember-concurrency</code>.</p>
<h2 id="обращение-к-предыдущему-ответу-сервера-после-того-как-повторный-запрос-завершился-неудачей">Обращение к предыдущему ответу сервера, после того как повторный запрос завершился неудачей</h2>
<p>Представьте такую ситуацию. Мы опрашиваем сервер каждую секунду, чтобы показывать актуальные данные. Мы хотим, чтобы в случае сетевого сбоя на экране продолжали отображаться последние успешно запрошенные данные.</p>
<p><code>ember-concurrency</code> предоставляет доступ к последним значениям resolution и rejection, если они имеются. Они остаются доступны, даже если задача перезапущена:</p>
<pre><code class="handlebars language-handlebars">{{gitHubRateTask.lastSuccessful.value}}</code></pre>
<p>Если мы поступим так же с <code>PromiseProxyMixin</code>, то значение на странице будет моргать каждую секунду. Ведь при каждом повторном запросе promise перезаписывается, и предыдущее resolution value становится недоступным.</p>
<p>Проще всего решить проблему, добавив <code>.then(result =&gt; this.set('result', result))</code> к promise, чтобы resolution value извлекался из promise и хранился отдельно.</p>
<p>Это нормальное решение, но оно мне не нравится своей императивностью. Вместо этого, взгляните на такой CP макрос:</p>
<pre><code class="js language-js">function cachingMacro (key) {
  let cache

  return computed(key, function () {
    const value = this.get(key)

    return value == null
      ? cache
      : cache = value
  })
}</code></pre>
<p>Его можно использовать так:</p>
<pre><code class="js language-js">gitHubRate:          cachingMacro('gitHubRateProxy.content'),
gitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),
gitHubRateLimit:     reads('gitHubRate.resources.core.limit'),</code></pre>
<p>В результате, когда promise перезаписывается вторым promise'ом, который завершается неудачей, свойство <code>gitHubRate</code> будет по-прежнему хранить resolution value первого promise'а.</p>
<p>Ну или вы можете применить <code>ember-concurrency</code> в конце концов. 😬</p>
<h2 id="что-скажете">Что скажете?</h2>
<p>Обязательно поделитесь вашими соображениями, возражениями и идеями в комментариях внизу. Самая ценная часть любой статьи — это всегда обсуждение, которое за ней следует!</p>]]></description><link>http://lolma.us/ru/blog/promise-proxy-mixin</link><guid isPermaLink="true">http://lolma.us/ru/blog/promise-proxy-mixin</guid><pubDate>Fri, 05 Jan 2018 00:00:00 GMT</pubDate></item><item><title><![CDATA[Возвращайте `RSVP.hash()` из `model`-хуков ваших маршрутов!]]></title><description><![CDATA[<p>Принято считать, что возврат хэша из <code>model</code>-хука — это плохая практика. Я убежден, что это не так! Я всегда возвращаю хэш по определенной схеме, и нахожу это чрезвычайно удобным.</p><h2 id="почему-это-считается-плохой-практикой">Почему это считается плохой практикой?</h2>
<p>Сам я никогда так не считал, поэтому давайте посмотрим, что об этом думает Ember-разработчик поумнее меня.</p>
<p>Sam Selikoff, героический автор <a href="http://www.ember-cli-mirage.com/">Mirage</a>, <a href="https://medium.com/@sam.selikoff/because-returning-a-single-domain-object-from-the-route-is-the-ember-pattern-the-very-name-of-the-94c4abf4ad58#.b6gzydbvt">в этом посте</a>высказался категорически против возврата хэша из <code>model</code>-хуков.</p>
<p>Хотя я определенно следую примеру Сэма в вопросах паттернов Ember, по данному конкретному вопросу смею решительно не согласиться.</p>
<p>Вот некоторые из его аргументов в моем кратком изложении. Обязательно прочтите оригинальный пост!</p>
<ul>
<li>Само имя хука — <code>model</code> — предполагает возврат одной сущности.</li>
<li>Необходиость возврата более одной сущности — это признак неудачно спроектированного <a href="https://ru.wikipedia.org/wiki/ER-модель_данных">ERM</a>.</li>
<li>Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель, имеющую relationships с необходимыми вам моделями. Такая связующая модель будет одной сущностью, представлющей определенную комбинацию свзяанных моделей.</li>
<li>Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте. Выберите самую важную из них и грузите ее, а остальные загружайте на уровне контроллера/компонента после первоначального рендеринга страницы.</li>
<li>В Rails, контроллеры должны создавать только одну сущность.</li>
</ul>
<p>Давайте посмотрим.</p>
<blockquote>
  <p>Само имя хука — <code>model</code> — предполагает возврат одной сущности.</p>
</blockquote>
<p>Имя метода не является для меня определяющим фактором. Прежде всего, в вэб-разработке понятие "модель" является широким. В контексте слоя модели из MVC, такого как Ember Data, "модель" означает класс, представляющий ресурс, и использующийся для создания записей-инстансов данного ресурса. Однако вне контекста MVC, "модель" -- это просто ваши данные, и они могут быть любыми, от простой строки до сложной, произвольно организованной JSON-подобной структуры.</p>
<p>Кроме того, Сэм не выступает против возврата массива из <code>model</code>-хука, несмотря на то, что название хука — не <code>models</code>.</p>
<blockquote>
  <p>Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель.</p>
  <p>Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте.</p>
</blockquote>
<p>Я нахожу рекомендацию рефакторить ERM так, чтобы каждый маршрут был представлен одной сущностью, идеалистической и наивной.</p>
<p>Это просто не всегда возможно. Очень часто приложение содержит маршруты, отображающие несколько самостоятельных, никак не связанных между собой моделей. При этом отображать страницу без некоторых из них -- бессмысленно с точки зрения бизнес-логики приложения.</p>
<p>Даже если ваши модели могут быть разумно объединены под связующей моделью, вы скорее всего столкнетесь с тем, что отрефакторить бэкенд затруднительно или вовсе невозможно. Например, у вас нет доступа к кодовой базе бэкенда или права вносить в нее изменения.</p>
<p>Можно было бы ввести связующую модель только на стороне фронтенда. В некоторых сложных случаях это оправдано (<a href="http://intercom.lolma.us/dublin/">пример</a>). Однако цена высока: ERM фронтенда и бэкенда начнут отличаться. Я считаю, что идти этим путем просто ради отказа от возврата хэша -- это бесмысленный расход ресурсов.</p>
<p>Даже если вы можете синхронизировать рефакторинг ERM на фронте и бэке, все равно это ужасно большой объем труда. И всё ради того, чтобы избежать этого простого паттерна.</p>
<blockquote>
  <p>В Rails, контроллеры должны создавать только одну сущность.</p>
</blockquote>
<p>Сравнивать Ember с "Рельсами" -- некорректно. Хотя они оба считаются MVC-фрэймворками, устроены они очень по-разному. У Rails вообще отсутствует класс "маршрут", а на каждый REST-запрос вызывается строго один контроллер, даже если адрес обращения представляет вложенный ресурс. В Ember же маршруты -- это сущности, ответственные за загрузку данных и вызываются по цепочке.</p>
<p>Но самое главное, Сэм не называет ни одного <em>практического</em> недостатка возврата хэша. Это потому, что недостатков нет! Зато есть преимущества.</p>
<h2 id="лучший-способ-возвращать-хэш-из-model-хука">Лучший способ возвращать хэш из <code>model</code>-хука</h2>
<p>Давайте я изложу, как я это делаю, после чего посмотрим на преимущества.</p>
<p><code>model</code>-хук каждого маршрута всегда должен возвращать <code>RSVP.hash()</code>. Даже если маршрут грузит всего лишь одну сущность, из хука возвращается хэш с одним свойством.</p>
<p>Трюк в том, что <strong>каждый хэш должен расширять хэш родительского маршрута</strong>. Разумеется, за иключением верхних маршрутов, не имеющих родителей.</p>
<p>Мои <code>model</code>-хуки выглядят примерно так:</p>
<pre><code class="js language-js">// posts route
model () {
  const store = this.get('store')

  return RSVP.hash({
    posts: store.findAll('post'),
  })
}</code></pre>
<pre><code class="js language-js">// posts.post route
{
  model ({postId}) {
    const store = this.get('store')
    const model = this.modelFor('posts')

    return RSVP.hash({
      ...model,
      currentPost: store.peekRecord('post', postId),
    })
  }
}</code></pre>
<p>Оператор <code>...</code> -- это <a href="https://www.google.ru/search?q=es2015+spread+operator">spread</a>, синтаксический сахар для <code>Ember.merge</code> и <code>Object.assign</code>.</p>
<p>Маршрут <code>posts.post</code> в итоге получит такую модель:</p>
<pre><code class="js language-js">{
  posts: [post1, post2, post3],
  currentPost: post2
}</code></pre>
<p>Давайте посмотрим, как это улучшает вашу кодовую базу!</p>
<h2 id="самоочевидный-код">Самоочевидный код</h2>
<p>Один из аргументов Сэма, который я не упоминал ранее, -- это что обращение к <code>model.posts</code> в шаблоне — это хуже, чем просто <code>model</code>. Я не согласен.</p>
<p>Когда я вижу <code>model</code> в шаблоне, это всегда  смущает и запутывает. Другое дело <code>model.posts</code> -- сразу очевидно, к какой сущности делается обращение.</p>
<h2 id="единообразный-доступ-к-доступным-данным-из-любого-шаблона">Единообразный доступ к доступным данным из любого шаблона</h2>
<p>С таким подходом, свойство <code>model</code> на каждом контроллере всегда будет содержать все данные, загруженные во всех родительских маршрутах.</p>
<p>Вы можете обратиться к любым данным из любого маршрута, без необходимости "прокидывать" их вручную, используя плохие приемы вроде <code>modelFor</code> из <code>setupController</code>, лишние сервисы или связующие модели.</p>
<p>Допустим, в маршруте конкретного поста мне нужно отобразить ссылки на предыдущий и следующий пост. Вот чего я <em>не</em> буду делать для решения этой задачи:</p>
<ul>
<li>Мне не потребуется вводить связи <code>previousPost</code> и <code>nextPost</code> на модели <code>post</code>.</li>
<li>Мне не нужно вводить новую сущность -- связующую модель, которая представляет пост вместе с двумя смежными постами.</li>
<li>Мне не нужно вызывать <code>store.peekRecord</code> на уровне компонента или контроллера.</li>
<li>Мне не нужно использовать <code>setupController</code>. Я вообще считаю <code>setupController</code> дурной практикой, которая отказывается от декларативных computed properties в пользу императивщины, без нужды увеличивающей связность приложения. Есть ровно одно оправданное применение <code>setupController</code>: прокидывать ошибку в <code>error</code>-маршрут.</li>
<li>Мне не нужно вводить сервис, задача которого — выдавать посты, смежные по отношению к данному.</li>
</ul>
<p><strong>Все, что мне требуется сделать, это обратиться к <code>model.posts</code>! Мне даже не интересно, в каком именно из родительских маршрутов были загружены эти записи.</strong></p>
<div class="exclamation"></div>
<blockquote>
  <p>Обратите внимание, что я не пропагандирую предзагрузку всех постов в маршруте <code>posts</code>. В простейшем случае, загружать список постов лучше в маршруте <code>posts.index</code>. Таким образром, посестелю не придется выгружать все посты, если он зашел почитать какой-то один из них.</p>
  <p>Но очень часто вам нужно предзагрузить все записи по какой-то другой причине. Например, вы хотите отображать облако тэгов, но у бэкенда нет API тэгов и тэги -- это просто атрибут на модели поста. Или вы хотите отобразить список недавних постов на боковой панели, но ваш бэкенд не поддерживает фильтрацию и лимит по количеству. Или у вас просто не так много записей этого типа, и предзагрузка из всех -- вполне приемлемое решение.</p>
  <p>В этих случаях вы все равно предзагружаете записи. Так почему бы не воспользоваться этим с пользой?</p>
</blockquote>
<h2 id="полагаемся-на-эффективность-computed-properties">Полагаемся на эффективность computed properties</h2>
<p>Итак, я нахожусь в маршруте конкретного поста, в свойстве <code>model.posts</code> лежит список всех постов, и я хочу отобразить ссылки на предыдущий и следующий посты.</p>
<p>В этом случае достаточно накидать несложную цепочку computed properties:</p>
<pre><code class="js language-js">import {sort}              from 'ember-computed'
import sum                 from 'ember-cpm/macros/sum'
import indexOf             from 'make/your/own/macro'
import getFromArrayByIndex from 'it/is/easy/and/fun'

{
  sortOrder:         'createdAd', // допустим, сортировка может регулироваться пользователем
  sortedPosts:       sort('model.posts', 'sortOrder'),
  currentPostIndex:  indexOf('sortedPosts', 'model.currentPost'),
  nextPostIndex:     sum('currentPostIndex', 1),
  previousPostIndex: sum('currentPostIndex', -1),
  nextPost:          getFromArrayByIndex('sortedPosts', 'nextPostIndex'),
  previousPost:      getFromArrayByIndex('sortedPosts', 'previousPostIndex'),
}</code></pre>
<pre><code class="handlebars language-handlebars">{{#if nextPost}}
  {{link-to (concat '← ' nextPost.title)     'posts.post' nextPost.id}}
{{/if}}

{{#if previousPost}}
  {{link-to (concat previousPost.title ' →') 'posts.post' previousPost.id}}
{{/if}}</code></pre>
<p>Этот код декларативен, защищен от багов, насколько это вообще возможно, и понятен с первого взгляда.</p>
<p>Кроме того, он производителен: значения computed properties кэшируются, и при повторном посещении маршрута контроллеру/компоненту не потребуется вычислять значения заново. Но если состав массива изменится, они сразу же пересчитаются автоматически.</p>
<h2 id="удобная-подгрузка-связанных-данных">Удобная подгрузка связанных данных</h2>
<p>Если вам нужно подгрузить связанные данные, это можно сделать очень наглядным способом.</p>
<p>В этом примере подгружаются авторы поста и всех комментариев</p>
<pre><code class="js language-js">{
  model ({postId}) {
    const store = this.get('store')
    const model = this.modelFor('posts')

    return RSVP
      .hash({
        ...model,
        currentPost: store.peekRecord('post', postId),
      })

      // Пост загрузился, давая возможнось получить его автора и комменты
      .then(model =&gt; RSVP.hash({
        ...model,
        author:   model.currentPost.get('author'),
        comments: model.currentPost.get('comments'),
      }))

      // Комменты загрузились, добываем их авторов:
      .then(model =&gt; RSVP.hash({
        ...model,
        commentAuthors: store.query('user', {
          'filter[ids]': this._getCommentAuthorIds(model.comments)
        })
      }))
  },

  // Удобный способ получить список айдишников авторов всех комментариев
  _getCommentAuthorIds (comments) {
    return comments
      .map(comment =&gt; comment.belongsTo('author').id())
      .join(',')
  },
}</code></pre>
<p>Одно из возражений Сэма заключается в том, из-за этого подхода разработчики не используют должным образом цепочку связей между моделями.</p>
<p>Я полностью согласен с тем, что в большинстве случаев обращаться к записи через цепочку связей, например, <code>model.currentPost.comments[n].author</code>) — лучше, чем, скажем, получать автора каждого коммента через поиск по массиву <code>model.commentAuthors</code>.</p>
<p>Но дело в том, что хоть все авторы доступны в свойстве <code>model.commentAuthors</code>, вы по-прежнему можете обращаться к авторам через цепочку связей. <code>model.commentAuthors</code> -- это просто легкочитаемый способ подгрузить данные, и он вовсе не ограничивает вас в возможности обходить граф моделей так, как вам удобно.</p>
<h2 id="eslint-спешит-на-помощь">ESLint спешит на помощь</h2>
<p>Если вы начнете использовать этот подход, то обнаружите, что JSHint спотыкается об оператор <code>...</code> и сходит с ума.</p>
<p>Это проблема не самого подхода, а использования морально устаревших инструментов.</p>
<p><code>ember install ember-eslint</code> решает эту проблему раз и навсегда. Не стоит отказываться от мощного spread-оператора из-за того, что JSHint не умеет в ES2015.</p>
<h2 id="что-вы-думаете-об-этом-подходе">Что вы думаете об этом подходе?</h2>
<p>Пожалуйста, поделитесь ниже в комментариях вашим мнением по этому поводу!</p>
<p>Делает ли данный подход вашу программерскую жизнь капельку приятнее?</p>
<p>Какие у него недостатки? Можно ли их решить, или же подход изначально ущербен?</p>]]></description><link>http://lolma.us/ru/blog/route-model-hook-rsvp-hash</link><guid isPermaLink="true">http://lolma.us/ru/blog/route-model-hook-rsvp-hash</guid><pubDate>Thu, 08 Dec 2016 00:00:00 GMT</pubDate></item></channel></rss>