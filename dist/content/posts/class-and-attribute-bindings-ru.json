{
  "data": {
    "id": "class-and-attribute-bindings-ru",
    "type": "posts",
    "attributes": {
      "id": "class-and-attribute-bindings-ru",
      "title": "Делаем динамические binding'и HTML-классов и атрибутов из родительского шаблона",
      "summary": "Стандартный способ применить динамические binding'и классов и атрибутов к компоненту ­— это определить их в классе компонента. Для встроенных и аддоновых компонентов для этого потребуется переопределять классы, чего часто делать не хочется. Хотелось бы просто передать binding'и из родительского шаблона без переопределения классов, но это работает не так, как вы думаете.",
      "created": "2018-01-06T00:00:00.000Z",
      "proficiency": "beginner",
      "body": "\n<div class=\"exclamation\"></div>\n\n> Это перевод моей статьи, которую я изначально опубликовал в блоге компании Deveo. Когда она была поглощена компанией Perforce, ее блог был закрыт.\n\n\n\nКаждый Ember-разработчик делал это много раз:\n\n```js\nEmber.Component.extend({\n  validationResult: Ember.computed(/*...*/),\n  classNameBindings: ['validationResult:is-valid:is-invalid']\n})\n```\n\nEmber применит к компоненту класс `is-valid` либо `is-invalid`, в зависиости от значения свойства `validationResult`.\n\nВ данном случае, свойство `validationResult` должно быть объявлено на самом компоненте. А где же еще, спросите вы?\n\n\n\n## Пробуем передать `classNameBindings` из родительского шаблона\n\nЖелание передать `classNameBindings` из родительского шаблона может возникнуть в том случае, если вам нужно применить динамический класс к компоненту, написанному не вами (встроенному в Ember или происходящему из аддона), и вам не хочется переопределять класс только ради этого.\n\nМоя интуиция подсказывает мне сделать так, но это **не заработает**:\n\n```handlebars\n{{textarea\n  validationResult  = (gte myText.length 100),\n  classNameBindings = 'validationResult:is-valid:is-invalid'\n}}\n```\n\n\n## Что происходит\n\n`classNameBindings` работает на основе устаревшего механизма binding'ов, который задокументирован [тут](http://emberjs.com/api/classes/Ember.Binding.html) и будет удален в Ember 3.\n\nИсторичеки, binding'и в Ember создавались при помощи этого низкоуровневого API. Затем ему на смену пришел удобный высокоуровневый API, которым мы пользуемся сейчас, и вместо `myPropBinding='foo'` мы пишем просто `myProp=foo`. Обратите внимание, что в первом случае название свойства передается в кавычках.\n\nУпрощая нюансы, этот код:\n\n```handlebars\n{{textarea\n  classNameBindings = 'validationResult:is-valid:is-invalid'\n}}\n```\n\nпримерно эквивалентен этому:\n\n```handlebars\n{{textarea\n  classNames = (if validationResult 'is-valid' 'is-invalid')\n}}\n```\n\nНо если вы попытаетесь сделать так, как показано в последнем примере, binding не будет динамическим. HTML-класс корректно примет исходное значение, но при изменении `validationResult` обновляться не будет.\n\nДля решения этой проблемы и нужны `classNameBinding`\n\n\n\n## Как правильно использовать `classNameBindings` на примере компонента `{{textarea}}` без его переопределения\n\nСвойство, которое вы указываете в `classNameBindings` в родительском шаблоне, должно быть объявлено в родительском компоненте/контроллере:\n\n```js\n// app/components/parent-component.js\nEmber.Component.extend({\n  name: 'Mike',\n  validationResult: Ember.computed.gte('name.length', 100),\n})\n```\n\n```handlebars\n{{! app/components/parent-component.hbs }}\n\n{{textarea\n  classNameBindings = 'validationResult:is-valid:is-invalid'\n}}\n```\n\nОчень важно понимать, чем этот пример отличается от самого первого примера статьи. На первый взгляд, они одинаковы, но это не так.\n\n* В первом примере статьи `classNameBindings` объявлен в классе дочернего компонента и ищет свойства в контексте дочернего компонента.\n\n* А в данном примере, `classNameBindings` хоть и передается в дочерний компонент, но прописан в родительском шаблоне и ищет свойства в родительском контексте!\n\n\n\n## Прописать несколько свойств в `classNameBindings` из родительского шаблона невозможно\n\nСогласно [документации компонента](https://emberjs.com/api/ember/2.18/classes/Component/properties/classNameBindings?anchor=classNameBindings), свойство `classNameBindings` должно содержать массив.\n\nЯ предполагал, что это сработает, но оно не работает:\n\n```handlebars\n{{textarea\n  classNameBindings = (array 'validationResult:is-valid:is-invalid')\n}}\n```\n\nЯ не нашел способа передать больше одного свойства в `classNameBindings`. Для этого все-таки требуется (пере)определять класс компонента и прописывать `classNameBindings` в нем.\n\nК счастью, есть способ лучше.\n\n\n\n## Используйте class вместо classNameBindings в родительском шаблоне!\n\nСвойство `class`, недоступное при объявлении класса компонента, можно передавать в компонент из родительского шаблона. И в нем можно передавать несколько binding'ов!\n\nВы наверняка делали это много раз:\n\n```handlebars\n<div class = \"foo {{bar}} {{if baz 'quux' 'zomg'}}\">\n```\n\nПри передаче `class` потребуется конкатенация:\n\n```handlebars\n{{my-component\n  class = (concat 'foo ' bar (if baz ' quux' ' zomg'))\n}}\n```\n\nОбратите внимание на дополнительные пробелы в строковых литералах.\n\n\n\n## Что насчет attributeBindings?\n\nEmber (Glimmer?) запрещет передавать `attributeBindings` из родительского шаблона. Такая запись сломает ваше приложение:\n\n```handlebars\n{{my-component\n  attributeBindings = \"foo\"\n}}\n```\n\nНекоторые Ember-аддоны используют mixin, который bind'ит все переданные извне свойства на HTML-атрибуты. С помощью такого mixin'а можно делать так:\n\n```handlebars\n{{my-component\n  disabled = isDisabled\n  data-foo = \"bar\"\n}}\n```\n\nК примеру, вот как выглядит приватный mixin `dynamic-attribute-bindings` аддона `ember-one-way-controls` [https://github.com/DockYard/ember-one-way-controls/blob/v3.0.1/addon/-private/dynamic-attribute-bindings.js](uses internally):\n\n```js\n// https://github.com/DockYard/ember-one-way-controls/blob/v3.0.1/addon/-private/dynamic-attribute-bindings.js\nimport Ember from 'ember';\n\nconst { Mixin, set } = Ember;\n\nexport default Mixin.create({\n  NON_ATTRIBUTE_BOUND_PROPS: ['class', 'classNames'],\n  concatenatedProperties: ['NON_ATTRIBUTE_BOUND_PROPS'],\n  init() {\n    this._super(...arguments);\n\n    let newAttributeBindings = [];\n    for (let key in this.attrs) {\n      if (this.NON_ATTRIBUTE_BOUND_PROPS.indexOf(key) === -1 && this.attributeBindings.indexOf(key) === -1) {\n        newAttributeBindings.push(key);\n      }\n    }\n\n    set(this, 'attributeBindings', this.attributeBindings.concat(newAttributeBindings));\n  }\n});\n```\n\nОбратите внимание, что этот mixin использует черный список. Все свойства, которые не упомянуты в `NON_ATTRIBUTE_BOUND_PROPS`, будут за'bind'ены на HTML-атрибуты. Свойство NON_ATTRIBUTE_BOUND_PROPS помечено как concatenated, т. е. если вы  его переопределите, то вместо переопределения произойдет пополнение массива, содержащегося в свойстве.\n\nВы можете изменить эту логику под свои задачи, например, применив белый список вместо черного.\n\n\n\n## Знаете больше? Поделитесь!\n\nВыражаю благодарность Ricardo Mendes ([@locks](https://github.com/locks)) за терпеливые разъяснения о том, как работает `classNameBindings`.\n\nЕсли вы увидите неточность в статье или можете лучше объяснить, что происходит с binding'ами классов и атрибутов, обязательно поделитесь в комментариях!\n"
    }
  }
}