{
  "data": {
    "id": "do-not-confuse-env-for-deploy-target-ru",
    "type": "posts",
    "attributes": {
      "id": "do-not-confuse-env-for-deploy-target-ru",
      "title": "Не путайте environment с deploy target",
      "summary": "У большинства фрэймворков есть понятие *environment*. Многие разработчики привязывают к environment параметры развертывания, что неверно.",
      "created": "2017-02-18T00:00:00.000Z",
      "updated": "2017-12-24T00:00:00.000Z",
      "proficiency": "beginner",
      "body": "\nНедавно я в очередной раз наткнулся на эту проблему и решил написать о ней данную заметку. Пишу с оглядкой на фронтенд-фрэймворк **EmberJS**, но суть применима к любому фронтенд- и бэкенд-фрйэмворку.\n\n\n\n## Термин environment слишком размыт\n\nТермин **environment** применяется очень широко, что вызывает путаницу. В интернете есть много статей, которые, если прочитать их поверхностно, противоречат тому, что я хочу посоветовать ниже. Долгое время эти статьи вызывали у меня недоумение. Пораскинув мозгами, я понял, что дело в путаной терминологии.\n\nВ **EmberJS** и многих других вэб-фрэймворках понятие **environment** применяется в достаточно узком смысле, и я далее буду придеживаться именно его. **Environment** — это набор параметров, конфигурирующих сборку и запуск вэб-приложения:\n\n*   минификация кода,\n*   asset fingerprinting/cache busting,\n*   генерация source maps,\n*   внедрение различных средств, облегчающих отладку,\n*   тестирование,\n*   внедрение маркеров для оценки покрытия кода,\n*   удаление тестировочных селекторов из HTML.\n\nНо есть и другая группа параметров, которую также принято включать в понятие **environment**. Я считаю, что это большая ошибка, и предлагаю отличать две группы. Вторую группу параметров я называю **deploy target**:\n\n*   адреса API,\n*   адреса CDN,\n*   настройки CSP (content security policy) и CORS (cross-origin resource sharing),\n*   ключи API.\n\n\n\n## В чем, собственно, проблема\n\nМногие разработчики сваливают обе группы параметров в одну кучу и привязывают к параметру **environment**, который у большинства фрэймворков может принимать всего три значения: `development`, `production` и `test`.\n\nВ результате приложение по сути имеет всего два режима сборки: production-билд, привязанный к production серверу, и development-билд привязанный к локальному серверу или моку (имитации сервера).\n\nСделать сборку в development-режиме, но привязанную к production серверу, затруднительно: для этого приходится временно редактировать конфиг. А ведь такая сборка может очень выручить, когда нужно отладить пробему, которая проявляется в продакшене, но не воспроизводится локально.\n\nОбратное тоже порой необходимо: сделать сборку для локального сервера, но в production режиме. Это нужно, например, чтобы замерить производительность или чтобы отладить проблему, возникающую во время минификации и фингерпринтинга.\n\nА хуже всего то, что ключи API хранятся прямо в конфиге и попадают в систему контроля версий, что угрожает безопасности вашего сервиса.\n\n\n\n## Как надо делать\n\nЯ рекомендую использовать так называемые *dotenv*-файлы.\n\nЭто конфигурационные файлы, имена которых начинаются с `.env-`. Они содержат определения переменных окружения в виде пар ключ=значение, по одной на строку:\n    \n```\nFOO=bar\nBAZ=quux\n```\n\nВаше приложение будет считывать нужный файл во время сборки и использовать соответствующие настройки.\n\nПеременные окружения по-английски называются **environment variables**, что добавляет путаницы, так что будьте внимательны. Переменные окружения — это такие переменные, которые можно передать из командной строки.\n\nВот, что вы должны сделать:\n\n1.  Удалите параметры группы **deploy target** из конфига приложения.\n\n2.  Вынесите их в dotenv-файлы, по одному для каждого сервера: `.env-production`, `.env-staging`, `.env-sandbox`, `.env-local`, `.env-mock` и т. д. Их может быть столько, сколько вам нужно, а не только production и development.\n\n3.  Обязательно добавьте dotenv-файлы в `.gitignore`, чтобы ключи API не засветились в системе контроля версий.\n\n4.  Если вы используете <abbr title=\"continuous integration\">CI</abbr>, содержимое этих файлов можно скопировать в настройки каждого сервера. На CodeShip, например, соответствующий раздел настроек называется \"deployment pipelines\".\n\n5.  Настройте приложение так, чтобы при сборке можно было указать, какой **deploy target** использовать. Большинство платформ имеют для этого библиотеку `dotenv`.\n\nТеперь **deploy target** можно выбирать отдельно от **environment**, получая любое нужное вам сочетание **deploy target** и **environment**. Например, я это делаю так:\n\n    DEPLOY_TARGET=local ember serve --environment=production\n\nРазумеется, для удобства вы можете настроить, чтобы для каждого **environment** автоматически использовался определенный **deploy target**, чтобы не приходилось указывать каждый раз.\n\nВнимательный читатель возразит: круг замкнулся, и **environment** снова опеределяет **deploy target**. За что боролись?\n\nПо-умолчанию всё останется как было, но у вас теперь появилась возможность в нужный момент вручную задействовать любое сочетание **environment** и **deploy target** — без необходимости редактировать код, а потом откатывать.\n\n\n\n## Как использовать dotenv в Ember\n\nNpm-библиотека [dotenv](https://www.npmjs.com/package/dotenv) может использоваться в Ember напрямую. Однако если вам нужно считывать параметры **deploy target** как в `config/environment.js`, так и в `ember-cli-build.js`, либо если вы используете FastBoot, то воспользуйтесь аддоном [ember-cli-dotenv](https://github.com/fivetanley/ember-cli-dotenv).\n\nСоздайте в корневой папке вашего Ember-приложения `.env`-файлы, по одному для каждого вашего сервера, включая локальный и мок-сервер, если вы их используете:\n\n    .env-production\n    .env-staging\n    .env-sandbox\n    .env-local\n    .env-mock\n\nОсобенно круто, если у ваших серверов есть имена собственные. В таком случае используйте эти имена в названиях `.env`-файлов.\n\nВ каждом файле храните параметры **deploy target** в таком виде:\n\n    MYAPP_BACKEND_API_URL=https://bravo.horns-and-hooves.com/api\n    MYAPP_BACKEND_API_VERSION=v18\n    MYAPP_IMAGES_CDN_URL=http://horns-and-hooves.cloudfront.net/bravo/images\n    MYAPP_GITHUB_API_KEY=jFViG9kZtY4NAJA8I65s\n\n`MYAPP` — это отсылка к названию вашего приложения. Добавлять его полезно, чтобы не переопределить какую-либо внешнюю переменную, которая может потребоваться и навзание которой может совпадать с одним из ваших.\n\nТеперь нам нужно добиться, чтобы `ember-cli-dotenv` подгружал нужный dotenv-файл. Для этого воспользуйтесь таким трюком в файле `config/environment.js`:\n\n```javascript\nconst fs = require('fs')\n\nconst environment   = process.env.EMBER_ENV || 'development'\nconst defaultTarget = environment === 'production' ? 'production' : 'localhost-4200'\nconst target        = process.env.DEPLOY_TARGET || defaultTarget\nconst dotEnvFile    = `./.env-${target}`\n\nif (fs.existsSync(dotEnvFile)) console.info(`using dotenv file: ${dotEnvFile}`)\nelse console.warn(`dot-env file not found: ${dotEnvFile}, assuming env vars are passed manually`)\n\n\n\nmodule.exports = function (env) {\n  return {\n    clientAllowedKeys : [\n      'MYAPP_BACKEND_API_URL',\n      'MYAPP_BACKEND_API_VERSION',\n      'MYAPP_IMAGES_CDN_URL',\n      'MYAPP_GITHUB_API_KEY',\n    ],\n    path : dotEnvFile,\n  }\n}\n```\n\nТеперь параметры из dotenv-файла попадут в хэш `process.env`, который вы можете использовать в `config/environment.js` и `ember-cli-build.js` следующим образом:\n\n```javascript\n{\n  gitHubApiKey: process.env.MYAPP_GITHUB_API_KEY\n}\n```\n\n<div class=\"exclamation\"></div>\n\n> Рекомендую дополнительно создать в вашем Ember-приложении сервис `config`, который будет проксировать настройки из `config/environment.js`. Это дает возможность использовать computed properties для формирования производных параметров, например, добавления версии API в адрес сервера.\n\nПо умолчанию, приведенный выше кгод будет использовать **deploy target** `production` в **environment** `production` и `localhost-4200` в `development`. Одредактируйте названия **deploy targets**, используемые в коде, чтобы совпали с вашими.\n\n\n     ember s -prod   # использует `production` environment с `production` deploy target\n     ember s         # использует `development` environment с `localhost-4200` deploy target\n\nВы можете указать, какой dotenv-файл использовать:\n\n    DEPLOY_TARGET=localhost-4200 ember s -prod   # использует `production` environment с `localhost-4200` deploy target\n    DEPLOY_TARGET=production ember s             # использует `development` environment с `production` deploy target\n\n\n## В сочетании с ember-cli-deploy\n\n`ember-cli-deploy` [имеет встроенную поодержку dotenv-файлов](http://ember-cli-deploy.com/docs/v1.0.x/using-env-for-secrets/), однако они используются только для команд `ember deploy`, в то время как описанный выше способ подходит не только для `ember deploy`, но и для `ember serve`, `ember build`, `ember test` и т. п.\n\nПри работе с `ember-cli-deploy` стоит обратить внимание на несколько нюансов.\n\nВо-первых, документация `ember-cli-deploy` использует словосочетание \"build environment\" в качестве синонима **deploy target**, что добавляет путаницы.\n\nВо-вторых, в конфиге `config/deploy.js` можно настраивать параметры сборки в зависимости от **deploy target**. Обязательно переименуйте **deploy targets** в этом файле, приведя их в соответствие названиям ваших dotenv-файлов.\n \nВ-третьих, не используйте сокращения `dev` и `prod` вместо `development` и `production`. \n\nВ-четвертых, обратите внимание, что `ember-cli-deploy` также применяет переменную окружения `DEPLOY_TARGET`. Однако она почему-то не используется для конфигурации из командной строки.\n\nИспользовать ее так нельзя:\n\n    DEPLOY_TARGET=production ember deploy\n\nВместо этого предлагается писать\n\n    ember deploy production\n    \nЗачем же в `ember-cli-deploy` вообще нужна переменная окружения `DEPLOY_TARGET`? Если у вас возникнет необходимость определить **deploy target** в файле `ember-cli-build.js`, то вы можете обратится к ней так: `process.env.DEPLOY_TARGET`.\n\nБеда в том, что файл `config/dotenv.js` отрабатывает раньше, чем команда `ember deploy production` переключает **environment** в `production` и присваивает значение переменной `DEPLOY_TARGET`. \n\nВыйти из положения можно, указывая `DEPLOY_TARGET` явно, чтобы `config/dotenv.js` использовал именно его.\n\n    DEPLOY_TARGET=production ember deploy production\n\nНо команда получается достаточно громоздкой. Избежать избыточности можно, научив ваш `config/dotenv.js` замечать команду `ember deploy production`:\n\n```js\nconst fs = require('fs')\n\nfunction getDeployTarget () {\n  return process.env.DEPLOY_TARGET || getDefaultDeployTarget()\n}\n\nfunction getDefaultDeployTarget () {\n  const environment =\n    process.env.EMBER_ENV\n    || deployEnv()\n    || 'development'\n\n  return environment === 'production' ? 'production' : 'localhost-4200'\n}\n\nfunction deployEnv () {\n  if (process.argv[2] === 'deploy' && process.argv[3] === 'prod') {\n    throw new Error(\"Command `ember deploy prod` is not supported. Please use `ember deploy production`.\")\n  } else if (process.argv[2] === 'deploy' && process.argv[3] === 'production') {\n    return 'production'\n  }\n}\n\n\n\nconst dotEnvFile   = `./.env-${getDeployTarget()}`\n\nif (fs.existsSync(dotEnvFile)) console.info(`Using dotenv file: ${dotEnvFile}`)\nelse console.warn(`dot-env file not found: ${dotEnvFile}, assuming env vars are passed manually`)\n\n\n\nmodule.exports = function (env) {\n  return {\n    clientAllowedKeys : [\n      'MYAPP_BACKEND_API_URL',\n      'MYAPP_BACKEND_API_VERSION',\n      'MYAPP_IMAGES_CDN_URL',\n      'MYAPP_GITHUB_API_KEY',\n    ],\n    path : dotEnvFile,\n  }\n}\n```\n\nВ результате команда `ember deploy production` задействует dotenv-файл `.env-production` и переключит **environment** в `production`.\n\nЕсли же вам понадобиться залить на production-сервер сборку без минификации, то вы можете воспользоваться командой:\n\n    EMBER_ENV=development ember deploy production\n\n\n\n## Ваше мнение?\n\nОбязательно поделитесь своими соображениями в комментариях!\n"
    }
  }
}