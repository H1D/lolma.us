{
  "data": {
    "id": "promise-proxy-mixin-ru",
    "type": "posts",
    "attributes": {
      "id": "promise-proxy-mixin-ru",
      "title": "PromiseProxyMixin: нативная альтернатива ember-concurrency",
      "summary": "ember-concurrency — исключительно мощный и полезный аддон. Однако если ваш единственный юз-кейс — это обращаться к серверу, то взгляните на легковесную альтернативу",
      "created": "2018-01-05T00:00:00.000Z",
      "proficiency": "beginner",
      "body": "\n<div class=\"exclamation\"></div>\n\n> Это перевод моей статьи, которую я изначально опубликовал в блоге компании Deveo. Когда она была поглощена компанией Perforce, ее блог был закрыт.\n\n\n\n\n[ember-concurrency](http://ember-concurrency.com) — это исключительно мощный и удобный аддон, решающий множество разнообразных задач.\n\nОднако самая типовая задача — просто обращаться к серверу: либо загружать данные, либо передавать. Вы можете посчитать чрезмерным устанавливать `ember-concurrency` только ради этого.\n\nИ будете совершенно правы. В Ember имеются все необходимые примитивы для решения этой задачи в том же стиле, что `ember-concurrency`: просто, эффективно и в рамках Ember way.\n\n\n\n## Пример задачи\n\nПозвольте продемонстрировать предлагаемый мной подход на простом примере. Мы будем получать с GitHub количество доступных обращений к GitHub API:\n\n    GET http://api.github.com/rate_limit\n\nЯ выбрал именно этот API endpoint, потому что это единственный endpoint, который GitHub не ограничивает по количеству обращений. :trollface:\n\nДавайте для начала реализуем метод загрузки данных:\n\n```js\nimport Controller from '@ember/controller'\nimport fetch from 'fetch'\n\nController.extend({\n  _fetchGitHubRate () {\n    return fetch('https://api.github.com/rate_limit')\n      .then(response => response.json());\n  },\n});\n```\n\nЯ использую аддон [ember-fetch](https://github.com/ember-cli/ember-fetch) ради его простоты, но на его месте может быть всё что угодно, что возвращает promise, например, сервис [ember-ajax](https://github.com/ember-cli/ember-ajax).\n\nМетод может находиться не только в контроллере, но и в любой другой сущности Ember: компоненте, сервисе, модели и т. д.\n\n\n\n## Встречайте `PromiseProxyMixin`\n\nВы наверняка слышали мнение, что возвращать promise из computed property (CP) — плохая идея. С [PromiseProxyMixin](https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin) это не так.\n\nДавайте создадим класс, в который включим `PromiseProxyMixin`. Это можно сделать на верхнем уровне вашего модуля:\n\n```js\nimport EmberObject from '@ember/object'\nimport PromiseProxyMixin from '@ember/object/promise-proxy-mixin'\n\nconst PromiseObject = EmberObject.extend(PromiseProxyMixin);\n```\n\nТеперь мы можем обернуть promise в `PromiseObject`. Обязательно разделите promise и proxy на два отдельных свойства:\n\n```js\n// This CP returns a simple promise\ngitHubRatePromise: computed(function () {\n  return this._fetchGitHubRate();\n}),\n\n// This CP wraps the promise with with `PromiseObject` \ngitHubRateProxy: computed('gitHubRatePromise', function () {\n  const promise = this.get('gitHubRatePromise');\n  return promise && PromiseObject.create({promise});\n}),\n```\n\nОбратите внимание на `promise &&`. Если promise отсутствует, proxy создаваться не должен, т. к. в этом случае он \"упадет\" с ошибкой.\n\n\n\n## Обращение к содержимому promise'а\n\nAPI endpoint, к которому мы обращаемся, возвращает данные в таком формате (фрагмент):\n\n```js\n{\n  \"resources\": {\n    \"core\": {\n      \"limit\": 60,\n      \"remaining\": 60,\n      \"reset\": 1486831110\n    },\n}\n```\n\nЭтот хэш будет доступен в шаблоне как `gitHubRateProxy.content`. Вы можете работать с этим свойством как обычно:\n\n```js\n  gitHubRate:          reads('gitHubRateProxy.content'),\n  gitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\n  gitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n```\n\nПока promise не resolved, эти свойства будут иметь значение `undefined`. Когда мы будем использовать их в другом computed property, надо защититься от `undefined`:\n\n```js\n  gitHubRatePercentage: computed('gitHubRateRemaining', 'gitHubRateLimit', function () {\n    const gitHubRateRemaining = this.get('gitHubRateRemaining');\n    const gitHubRateLimit     = this.get('gitHubRateLimit');\n    \n    // We don't want a `NaN`!\n    if (gitHubRateRemaining == null || gitHubRateLimit == null) return;\n    \n    const percentage  = Math.round(gitHubRateRemaining / gitHubRateLimit * 100);\n    \n    return `${percentage}%`;\n  }),\n```\n\nПрименим результат в шаблоне:\n\n```handlebars\nYour GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n```\n\n\n\n## Как это работает\n\nИзначально, CP `gitHubRatePromise` не рассчитано, и обращение к серверу не происходит.\n\nКогда рендерится наш шаблон, происходит считывание свойства `gitHubRateRemaining`. Это CP зависит от `gitHubRateProxy`. Тот, в свою очередь, обращается к `gitHubRatePromise`.\n\nПри первом обращении к `gitHubRatePromise` выполняется метод `_fetchGitHubRate` и совершается запрос. Метод возвращает promise, который кэшируется в свойстве `gitHubRatePromise`.\n\nЭто означает, что при повторном обращении к свойству будет возвращаться один и тот же promise, и запрос не будет выполняться повторно. По сути, реализуется паттерн `drop` из `ember-concurrency`.\n\nСвойство `gitHubRateProxy` оборачивае promise в proxy `PromiseObject`. Когда promise отресолвится, его resolve value станет доступно как `gitHubRateProxy.content`.\n\nОбратите внимание, что данный подход декларативен. Вам не требуется делать этого:\n\n```js\ndidInsertElement () {\n  this._super()\n  this.get('fetchGitHubRateTask').perform()\n}\n```\n\n\n\n## Учитываем, что выполнение promise занимает время\n\nПока promise не отресолвится, содержимое `gitHubRateProxy.content` будет `undefined`. Это означает, что пока запрос выполняется, в шаблоне будет пустота. Давайте это исправим.\n\n`PromiseProxyMixin` предоставляет свойство `gitHubRateProxy.isPending`. Воспользуемся им в шаблоне:\n\n```handlebars\n{{#if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\nВполне естественная запись. Выходит, возвращать promise из computed property не так уж плохо! :wink:\n\n\n\n## Учитываем, что запрос может завершиться неудачей\n\nВнимательный четатель мог заметить проблему: если promise будет rejected, например, вследствие сетевого сбоя, то reject'нутое состояние promise'а будет закэшировано навсегда. В этом проявляется одно из преимуществ `ember-concurrency`: он позволяет без труда перезапустить задачу.\n\nВ случае с promise нам понадобиться написать несколько строк кода. Идея в том, чтобы перезаписать computed property `gitHubRatePromise` обычным, не computed, promise'ом:\n\n```js\n  actions: {\n    refetchGitHubRate () {\n      this.set('gitHubRatePromise', this._fetchGitHubRate());\n    }\n  },\n```\n\nВызов этого action'а спровоцирует новый сетевой запрос. Соответствующий promise будет присвоен в свойство `gitHubRatePromise`, что вызовет пересчет всех свойств, которые от него зависят, и далее по цепочке.\n\nЕсли promise будет rejected, то свойство `gitHubRateProxy.isRejected` примет значение `true`, а rejection value (обычно это объект Error) будет доступно в `gitHubRateProxy.reason`.\n\nДавайте попробуем:\n\n```handlebars\n{{#if gitHubRateProxy.isRejected}}\n\n  Failed to retrieve GitHub rate limit.<br>\n    \n  Reason: {{gitHubRateProxy.reason}}<br>\n    \n  <a href {{action 'refetchGitHubRate'}}>\n    Retry\n  </a>\n    \n{{else if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\n\n## Демо\n\nПосмотреть полный код примера и попробовать его в деле вы можете [на Ember Twiddle](https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs):\n\n<iframe src=\"https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?fullScreen=true\" style=\"width: 100%; height: 500px; border: 2px solid biege;\"></iframe><br>\n\n[Тут](https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs) вы найдете аналогичный пример на `ember-concurrency` для сравнения.\n\n\n\n## Переносим логику в севрис для переиспользования\n\nЕсли вы поместили описанную логику в компонент, который используется в двух разных маршрутах, то при переходе между маршрутами данные будут запрашиваться повторно, поскольку при покидании маршрута компонент уничтожается, а вместе с ним и promise.\n\nВероятно, предпочтительнее будет не перезапрашивать данные при смене маршрута, а делать это только по запросу. Для этого promise должен кэшироваться глобально и не быть привязан к компоненту.\n\nОчевидное решение — поместить эту логику в сервис. Очень удобно для этого расширять сервис [ember-ajax](https://github.com/ember-cli/ember-ajax).\n\n\n\n## `Ember.ObjectProxy` не нужен\n\n[Официальная документация по PromiseProxyMixin](https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin) предлагает использовать`Ember.ObjectProxy` в качестве базвого класса для примешивания `PromiseProxyMixin`. Однако `ObjectProxy` применяет кое-какую черную магию, из-за чего я предпочитаю его избегать.\n\nЕдинственное преимущество `ObjectProxy` — это сократить этот путь:\n\n    gitHubRateProxy.content.resources.core.remaining\n\nдо этого:\n\n    gitHubRateProxy.resources.core.remaining\n\nВсего лишь пропадает необходимость писать `.content`. Не такая уж большая польза.\n\nЕстественно, эта черная магия не работает с массивами. Для массивов предлагается использовать `Ember.ArrayProxy`, который в свою очередь не работает с объектами. А если ваш promise возвращает инстанс класса, а не просто хэш, то не подходит ни один из вариантов.\n\n`Ember.Object`, напротив, универсален. Необходимость дописывать `.content` — это малая цена за прозрачность происходящего. Я думаю, `ObjectProxy` and `ArrayProxy` — это пережитки времен давно ушедших  `ObjectController` и `ArrayController`.\n\n\n\n## `ember-deferred-content` и `ember-async-button` тоже не нужны\n\nЭти два аддона оборачивают promise в proxy на уровне шаблона. Они предлагают своеобразные шаблонные конструкции, не имея никаких преимуществ над `PromiseProxyMixin`.\n\nСравните:\n\n```handlebars\n{{#if gitHubRateProxy.isRejected}}\n\n  Failed to retrieve GitHub rate limit.<br>\n    \n  Reason: {{gitHubRateProxy.reason}}<br>\n    \n  <a href {{action 'refetchGitHubRate'}}>\n    Retry\n  </a>\n    \n{{else if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\n```handlebars\n{{#deferred-content gitHubRatePromise as |d|}}\n  {{#d.pending}}\n    Retrieving GitHub rate limit...\n  {{/d.pending}}\n\n  {{#d.fulfilled as |gitHubRate|}}\n    Your GitHub rate limit:\n\n    {{gitHubRate.resources.core.remaining}}\n\n    ({{multiply\n      (divide gitHubRate.resources.core.remaining gitHubRate.resources.core.limit)\n      100\n    }}%)\n  {{/d.fulfilled}}\n\n  {{#d.rejected as |reason|}}\n    Failed to retrieve GitHub rate limit.<br>\n      \n    Reason: {{reason}}<br>\n      \n    <a href {{action 'refetchGitHubRate'}}>\n      Retry\n    </a>\n  {{/d.rejected}}\n{{/deferred-content}}\n```\n\nОбратите внимание, что `ember-deferred-content` вынуждает вас вычислять проценты на уровне шаблона.\n\n\n\n## Я не отговариваю вас использовать `ember-concurrency`\n\nОсновная цель этой статьи — показать вам данный прием и заставить немного задуматься. Этот прием весьма практичен, и я часто пользуюсь им в своих проектах, где не используется `ember-concurrency`.\n\nОтказаться от `ember-concurrency` в пользу `PromiseProxyMixin` можно по двум причинам:\n\n* вы считаете каждый килобайт размера вашего дистрибутива;\n* вы хотите обойтись без лишних сущностей, слоев и абстракций.\n\nЕсли же вы уже хорошо знакомы с `ember-concurrency`, и он включен в ваш проект, то использовать `PromiseProxyMixin` нет смысла. Скорее всего, код на `ember-concurrency` получится немного короче:\n\n```js\ngitHubRateTask: task(function * () {\n  return yield this._fetchGitHubRate();\n}).restartable().on('didInsertElement')\n\ngitHubRate:          reads('gitHubRateTask.last.value'),\ngitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\ngitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n\n// Если этого не сделать, запрос не будет выполнен. Императивненько. :(\ndidInsertElement () {\n  this._super()\n  this.get('fetchGitHubRateTask').perform()\n}\n```\n\nПовторяю [ссылку](https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs) на пример, выполненный на `ember-concurrency`.\n\n\n\n## Обращение к предыдущему ответу сервера, после того как повторный запрос завершился неудачей\n\nПредставьте такую ситуацию. Мы опрашиваем сервер каждую секунду, чтобы показывать актуальные данные. Мы хотим, чтобы в случае сетевого сбоя на экране продолжали отображаться последние успешно запрошенные данные.\n\n`ember-concurrency` предоставляет доступ к последним значениям resolution и rejection, если они имеются. Они остаются доступны, даже если задача перезапущена:\n\n```handlebars\n{{gitHubRateTask.lastSuccessful.value}}\n```\n\nЕсли мы поступим так же с `PromiseProxyMixin`, то значение на странице будет моргать каждую секунду. Ведь при каждом повторном запросе promise перезаписывается, и предыдущее resolution value становится недоступным.\n\nПроще всего решить проблему, добавив `.then(result => this.set('result', result))` к promise, чтобы resolution value извлекался из promise и хранился отдельно.\n\nЭто нормальное решение, но оно мне не нравится своей императивностью. Вместо этого, взгляните на такой CP макрос:\n\n```js\nfunction cachingMacro (key) {\n  let cache\n\n  return computed(key, function () {\n    const value = this.get(key)\n    \n    return value == null\n      ? cache\n      : cache = value\n  })\n}\n```\n\nЕго можно использовать так:\n\n```js\ngitHubRate:          cachingMacro('gitHubRateProxy.content'),\ngitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\ngitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n```\n\nВ результате, когда promise перезаписывается вторым promise'ом, который завершается неудачей, свойство `gitHubRate` будет по-прежнему хранить resolution value первого promise'а.\n\nНу или вы можете применить `ember-concurrency` в конце концов. :grimacing:\n\n\n\n## Что скажете?\n\nОбязательно поделитесь вашими соображениями, возражениями и идеями в комментариях внизу. Самая ценная часть любой статьи — это всегда обсуждение, которое за ней следует!\n"
    }
  }
}