{
  "data": {
    "id": "route-model-hook-rsvp-hash-ru",
    "type": "posts",
    "attributes": {
      "id": "route-model-hook-rsvp-hash-ru",
      "title": "Возвращайте `RSVP.hash()` из `model`-хуков ваших маршрутов!",
      "summary": "Принято считать, что возврат хэша из `model`-хука — это плохая практика. Я убежден, что это не так! Я всегда возвращаю хэш по определенной схеме, и нахожу это чрезвычайно удобным.",
      "created": "2016-12-08T00:00:00.000Z",
      "proficiency": "beginner",
      "body": "\n\n\n## Почему это считается плохой практикой?\n\nСам я никогда так не считал, поэтому давайте посмотрим, что об этом думает Ember-разработчик поумнее меня.\n\nSam Selikoff, героический автор [Mirage](http://www.ember-cli-mirage.com/), [в этом посте](https://medium.com/@sam.selikoff/because-returning-a-single-domain-object-from-the-route-is-the-ember-pattern-the-very-name-of-the-94c4abf4ad58#.b6gzydbvt)высказался категорически против возврата хэша из `model`-хуков.\n\nХотя я определенно следую примеру Сэма в вопросах паттернов Ember, по данному конкретному вопросу смею решительно не согласиться.\n\nВот некоторые из его аргументов в моем кратком изложении. Обязательно прочтите оригинальный пост!\n\n*   Само имя хука — `model` — предполагает возврат одной сущности.\n*   Необходиость возврата более одной сущности — это признак неудачно спроектированного [ERM](https://ru.wikipedia.org/wiki/ER-модель_данных).\n*   Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель, имеющую relationships с необходимыми вам моделями. Такая связующая модель будет одной сущностью, представлющей определенную комбинацию свзяанных моделей.\n*   Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте. Выберите самую важную из них и грузите ее, а остальные загружайте на уровне контроллера/компонента после первоначального рендеринга страницы.\n*   В Rails, контроллеры должны создавать только одну сущность.\n\nДавайте посмотрим.\n\n> Само имя хука — `model` — предполагает возврат одной сущности.\n\nИмя метода не является для меня определяющим фактором. Прежде всего, в вэб-разработке понятие \"модель\" является широким. В контексте слоя модели из MVC, такого как Ember Data, \"модель\" означает класс, представляющий ресурс, и использующийся для создания записей-инстансов данного ресурса. Однако вне контекста MVC, \"модель\" -- это просто ваши данные, и они могут быть любыми, от простой строки до сложной, произвольно организованной JSON-подобной структуры.\n\nКроме того, Сэм не выступает против возврата массива из `model`-хука, несмотря на то, что название хука — не `models`.\n\n> Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель.\n>\n> Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте.\n\nЯ нахожу рекомендацию рефакторить ERM так, чтобы каждый маршрут был представлен одной сущностью, идеалистической и наивной.\n\nЭто просто не всегда возможно. Очень часто приложение содержит маршруты, отображающие несколько самостоятельных, никак не связанных между собой моделей. При этом отображать страницу без некоторых из них -- бессмысленно с точки зрения бизнес-логики приложения.\n\nДаже если ваши модели могут быть разумно объединены под связующей моделью, вы скорее всего столкнетесь с тем, что отрефакторить бэкенд затруднительно или вовсе невозможно. Например, у вас нет доступа к кодовой базе бэкенда или права вносить в нее изменения.\n\nМожно было бы ввести связующую модель только на стороне фронтенда. В некоторых сложных случаях это оправдано ([пример](http://intercom.lolma.us/dublin/)). Однако цена высока: ERM фронтенда и бэкенда начнут отличаться. Я считаю, что идти этим путем просто ради отказа от возврата хэша -- это бесмысленный расход ресурсов.\n\nДаже если вы можете синхронизировать рефакторинг ERM на фронте и бэке, все равно это ужасно большой объем труда. И всё ради того, чтобы избежать этого простого паттерна.\n\n> В Rails, контроллеры должны создавать только одну сущность.\n\nСравнивать Ember с \"Рельсами\" -- некорректно. Хотя они оба считаются MVC-фрэймворками, устроены они очень по-разному. У Rails вообще отсутствует класс \"маршрут\", а на каждый REST-запрос вызывается строго один контроллер, даже если адрес обращения представляет вложенный ресурс. В Ember же маршруты -- это сущности, ответственные за загрузку данных и вызываются по цепочке.\n\nНо самое главное, Сэм не называет ни одного *практического* недостатка возврата хэша. Это потому, что недостатков нет! Зато есть преимущества.\n\n\n## Лучший способ возвращать хэш из `model`-хука\n\nДавайте я изложу, как я это делаю, после чего посмотрим на преимущества.\n\n`model`-хук каждого маршрута всегда должен возвращать `RSVP.hash()`. Даже если маршрут грузит всего лишь одну сущность, из хука возвращается хэш с одним свойством.\n\nТрюк в том, что **каждый хэш должен расширять хэш родительского маршрута**. Разумеется, за иключением верхних маршрутов, не имеющих родителей.\n\nМои `model`-хуки выглядят примерно так:\n\n```js\n// posts route\nmodel () {\n  const store = this.get('store')\n  \n  return RSVP.hash({\n    posts: store.findAll('post'),\n  })\n}\n```\n\n```js\n// posts.post route\n{\n  model ({postId}) {\n    const store = this.get('store')\n    const model = this.modelFor('posts')\n    \n    return RSVP.hash({\n      ...model,\n      currentPost: store.peekRecord('post', postId),\n    })\n  }\n}\n```\n\nОператор `...` -- это [spread](https://www.google.ru/search?q=es2015+spread+operator), синтаксический сахар для `Ember.merge` и `Object.assign`.\n\nМаршрут `posts.post` в итоге получит такую модель:\n\n```js\n{\n  posts: [post1, post2, post3],\n  currentPost: post2\n}\n```\n\nДавайте посмотрим, как это улучшает вашу кодовую базу!\n\n\n\n## Самоочевидный код\n\nОдин из аргументов Сэма, который я не упоминал ранее, -- это что обращение к `model.posts` в шаблоне — это хуже, чем просто `model`. Я не согласен.\n\nКогда я вижу `model` в шаблоне, это всегда  смущает и запутывает. Другое дело `model.posts` -- сразу очевидно, к какой сущности делается обращение.\n\n\n\n## Единообразный доступ к доступным данным из любого шаблона\n\n\nС таким подходом, свойство `model` на каждом контроллере всегда будет содержать все данные, загруженные во всех родительских маршрутах.\n\nВы можете обратиться к любым данным из любого маршрута, без необходимости \"прокидывать\" их вручную, используя плохие приемы вроде `modelFor` из `setupController`, лишние сервисы или связующие модели.\n\nДопустим, в маршруте конкретного поста мне нужно отобразить ссылки на предыдущий и следующий пост. Вот чего я *не* буду делать для решения этой задачи:\n\n*    Мне не потребуется вводить связи `previousPost` и `nextPost` на модели `post`.\n*    Мне не нужно вводить новую сущность -- связующую модель, которая представляет пост вместе с двумя смежными постами.\n*    Мне не нужно вызывать `store.peekRecord` на уровне компонента или контроллера.\n*    Мне не нужно использовать `setupController`. Я вообще считаю `setupController` дурной практикой, которая отказывается от декларативных computed properties в пользу императивщины, без нужды увеличивающей связность приложения. Есть ровно одно оправданное применение `setupController`: прокидывать ошибку в `error`-маршрут.\n*    Мне не нужно вводить сервис, задача которого — выдавать посты, смежные по отношению к данному.\n\n**Все, что мне требуется сделать, это обратиться к `model.posts`! Мне даже не интересно, в каком именно из родительских маршрутов были загружены эти записи.**\n\n<div class=\"exclamation\"></div>\n\n> Обратите внимание, что я не пропагандирую предзагрузку всех постов в маршруте `posts`. В простейшем случае, загружать список постов лучше в маршруте `posts.index`. Таким образром, посестелю не придется выгружать все посты, если он зашел почитать какой-то один из них.\n> \n> Но очень часто вам нужно предзагрузить все записи по какой-то другой причине. Например, вы хотите отображать облако тэгов, но у бэкенда нет API тэгов и тэги -- это просто атрибут на модели поста. Или вы хотите отобразить список недавних постов на боковой панели, но ваш бэкенд не поддерживает фильтрацию и лимит по количеству. Или у вас просто не так много записей этого типа, и предзагрузка из всех -- вполне приемлемое решение.\n> \n> В этих случаях вы все равно предзагружаете записи. Так почему бы не воспользоваться этим с пользой?\n\n\n\n## Полагаемся на эффективность computed properties\n\nИтак, я нахожусь в маршруте конкретного поста, в свойстве `model.posts` лежит список всех постов, и я хочу отобразить ссылки на предыдущий и следующий посты.\n\nВ этом случае достаточно накидать несложную цепочку computed properties:\n\n```js\nimport {sort}              from 'ember-computed'\nimport sum                 from 'ember-cpm/macros/sum'\nimport indexOf             from 'make/your/own/macro'\nimport getFromArrayByIndex from 'it/is/easy/and/fun'\n\n{\n  sortOrder:         'createdAd', // допустим, сортировка может регулироваться пользователем\n  sortedPosts:       sort('model.posts', 'sortOrder'),\n  currentPostIndex:  indexOf('sortedPosts', 'model.currentPost'),\n  nextPostIndex:     sum('currentPostIndex', 1),\n  previousPostIndex: sum('currentPostIndex', -1),\n  nextPost:          getFromArrayByIndex('sortedPosts', 'nextPostIndex'),\n  previousPost:      getFromArrayByIndex('sortedPosts', 'previousPostIndex'),\n}\n```\n\n```handlebars\n{{#if nextPost}}\n  {{link-to (concat '← ' nextPost.title)     'posts.post' nextPost.id}}\n{{/if}}\n\n{{#if previousPost}}\n  {{link-to (concat previousPost.title ' →') 'posts.post' previousPost.id}}\n{{/if}}\n```\n\nЭтот код декларативен, защищен от багов, насколько это вообще возможно, и понятен с первого взгляда.\n\nКроме того, он производителен: значения computed properties кэшируются, и при повторном посещении маршрута контроллеру/компоненту не потребуется вычислять значения заново. Но если состав массива изменится, они сразу же пересчитаются автоматически.\n\n\n\n## Удобная подгрузка связанных данных\n\nЕсли вам нужно подгрузить связанные данные, это можно сделать очень наглядным способом.\n\nВ этом примере подгружаются авторы поста и всех комментариев\n\n```js\n{\n  model ({postId}) {\n    const store = this.get('store')\n    const model = this.modelFor('posts')\n    \n    return RSVP\n      .hash({\n        ...model,\n        currentPost: store.peekRecord('post', postId),\n      })\n      \n      // Пост загрузился, давая возможнось получить его автора и комменты\n      .then(model => RSVP.hash({\n        ...model,\n        author:   model.currentPost.get('author'),\n        comments: model.currentPost.get('comments'),\n      }))\n      \n      // Комменты загрузились, добываем их авторов:\n      .then(model => RSVP.hash({\n        ...model,\n        commentAuthors: store.query('user', {\n          'filter[ids]': this._getCommentAuthorIds(model.comments)\n        })\n      }))\n  },\n  \n  // Удобный способ получить список айдишников авторов всех комментариев\n  _getCommentAuthorIds (comments) {\n    return comments\n      .map(comment => comment.belongsTo('author').id())\n      .join(',')\n  },\n}\n```\n\nОдно из возражений Сэма заключается в том, из-за этого подхода разработчики не используют должным образом цепочку связей между моделями.\n\nЯ полностью согласен с тем, что в большинстве случаев обращаться к записи через цепочку связей, например, `model.currentPost.comments[n].author`) — лучше, чем, скажем, получать автора каждого коммента через поиск по массиву `model.commentAuthors`.\n\nНо дело в том, что хоть все авторы доступны в свойстве `model.commentAuthors`, вы по-прежнему можете обращаться к авторам через цепочку связей. `model.commentAuthors` -- это просто легкочитаемый способ подгрузить данные, и он вовсе не ограничивает вас в возможности обходить граф моделей так, как вам удобно.\n\n\n\n## ESLint спешит на помощь\n\nЕсли вы начнете использовать этот подход, то обнаружите, что JSHint спотыкается об оператор `...` и сходит с ума.\n\nЭто проблема не самого подхода, а использования морально устаревших инструментов.\n\n`ember install ember-eslint` решает эту проблему раз и навсегда. Не стоит отказываться от мощного spread-оператора из-за того, что JSHint не умеет в ES2015.\n\n\n\n## Что вы думаете об этом подходе?\n\nПожалуйста, поделитесь ниже в комментариях вашим мнением по этому поводу!\n\nДелает ли данный подход вашу программерскую жизнь капельку приятнее?\n\nКакие у него недостатки? Можно ли их решить, или же подход изначально ущербен?\n"
    }
  }
}