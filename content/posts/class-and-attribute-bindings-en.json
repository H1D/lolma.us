{
  "data": {
    "id": "class-and-attribute-bindings-en",
    "type": "posts",
    "attributes": {
      "id": "class-and-attribute-bindings-en",
      "title": "What you didn't know about passing dynamic classname and attribute bidings from parent template",
      "summary": "The straightforward way of applying dynamic class/attribute bindings to a component is within that component's class definition. For build-in and third-party components that would require subclassing, which is often undesirable. It's tempting to pass the bindings from a parent template without subclassing, but that works not how you think it works.",
      "created": "2017-04-13T00:00:00.000Z",
      "updated": "2018-01-06T00:00:00.000Z",
      "proficiency": "beginner",
      "body": "\n<div class=\"exclamation\"></div>\n\n> This article was originally posted on Deveo blog.\n> \n> When Deveo was acquired by Perforce, Deveo blog was turned down.\n\n\n\nEvery Ember developer has done this many times:\n\n```js\nEmber.Component.extend({\n  validationResult: Ember.computed(/*...*/),\n  classNameBindings: ['validationResult:is-valid:is-invalid']\n})\n```\n\nEmber will apply either `is-valid` or `is-invalid` HTML class to the component depending on whether `validationResult` property is truthy.\n\nIn this case, the `validationResult` property is looked upon the component.\n\n\n\n## Trying to pass `classNameBindings` externally\n\nThere are situations when you want to pass `classNameBindings` into a component from the parent template.\n\nSay, you need a custom HTML class on the `{{textarea}}` component, but you don't want to bother subclassing the `Ember.TextArea` component. Why create a custom component when you can simply pass `classNameBindings` and `validationResult` into the standard `{{textarea}}`, right?\n\nThis is what my intuition tells me to do, but it **does not work**:\n\n```handlebars\n{{textarea\n  validationResult  = (gte myText.length 100),\n  classNameBindings = 'validationResult:is-valid:is-invalid'\n}}\n```\n\n\n## What happens\n\n`classNameBindings` is operated by Ember's **deprecated** binding mechanism. The mechanism is documented [here](http://emberjs.com/api/classes/Ember.Binding.html) and is removed in Ember 3.\n\nHistorically, this low-level API was used to set up bindings in EmberJS. Then it was replaced with the convenient high-level API that we know today, and instead of `myPropBinding='foo'` we can simply do `myProp=foo` in our templates. Note that the former uses quotes and the latter doesn't.\n\nThis code:\n\n```handlebars\n{{textarea\n  classNameBindings = 'validationResult:is-valid:is-invalid'\n}}\n```\n\nis roughly equivalent to this:\n\n```handlebars\n{{textarea\n  classNames = (if validationResult 'is-valid' 'is-invalid')\n}}\n```\n\nBut if you use the latter in your template, the HTML class will not be dynamic. It will use the initial value of `validationResult`, and when `validationResult` changes, the HTML class will not be updated.\n\nThis is why `classNameBindings` is there for you.\n\n\n\n## Passing `classNameBindings` into the default textarea component\n\nYou have to define the property on the *parent* component/controller and use its name in `classNameBindings`:\n\n```js\n// app/components/parent-component.js\nEmber.Component.extend({\n  validationResult: Ember.computed(/*...*/),\n})\n```\n\n```handlebars\n{{! app/components/parent-component.hbs }}\n\n{{textarea\n  classNameBindings = 'validationResult:is-valid:is-invalid'\n}}\n```\n\nIt is very important to understand that this example is different from the first example in this article, even though it feels identical to `classNameBindings: 'validationResult:is-valid:is-invalid'`.\n\n* In the first example of this article, `classNameBindings` is evaluated in the context of the same component that it's applied to.\n\n* In this example, `classNameBindings` is applied to the `{{textarea}}` component, but it is evaluated in the context of the parent component/controller!\n\n\n\n## Passing multiple properties into `classNameBindings` externally seems to be impossible\n\nI assumed this would work, but it doesn't:\n\n```handlebars\n{{textarea\n  classNameBindings = (array 'validationResult:is-valid:is-invalid')\n}}\n```\n\n...where `array` is a simple helper that returns its arguments as an array.\n\n\nI did not find a way to pass more than one property into `classNameBindings`. If you need that, you'll have to subclass the component in question, so that you can apply `classNameBindings` internally, in the component's own JS file.\n\nLuckily, there's a better way.\n\n\n\n## Use class instead of classNameBindings in the parent template\n\nThe `class` property, unavailable (or at least not documented) inside a component class, can be passed externally. And it allows defining multiple dynamic bindings!\n\nYou've probably done that many times:\n\n```handlebars\n<div class = \"foo {{bar}} {{if baz 'quux' 'zomg'}}\">\n```\n\nIf you pass `class` to a component, you need concatenation:\n\n```handlebars\n{{my-component\n  class = (concat 'foo ' bar (if baz ' quux' ' zomg'))\n}}\n```\n\nNote extra spaces in string literals.\n\n\n\n## What about attributeBindings?\n\nEmber (Glimmer?) explicitly forbids passing `attributeBindings` from inside a parent tempalte. This will crash your app:\n\n```handlebars\n{{my-component\n  attributeBindings = \"foo\"\n}}\n```\n\nSome Ember addons use a mixin that binds all properties passed from parent template to HTML attributes. With such a mixin, you could do this:\n\n```handlebars\n{{my-component\n  disabled = isDisabled\n  data-foo = \"bar\"\n}}\n```\n\nHere's how a private mixin `dynamic-attribute-bindings` from `ember-one-way-controls`[https://github.com/DockYard/ember-one-way-controls/blob/v3.0.1/addon/-private/dynamic-attribute-bindings.js](looks like):\n\n```js\n// https://github.com/DockYard/ember-one-way-controls/blob/v3.0.1/addon/-private/dynamic-attribute-bindings.js\nimport Ember from 'ember';\n\nconst { Mixin, set } = Ember;\n\nexport default Mixin.create({\n  NON_ATTRIBUTE_BOUND_PROPS: ['class', 'classNames'],\n  concatenatedProperties: ['NON_ATTRIBUTE_BOUND_PROPS'],\n  init() {\n    this._super(...arguments);\n\n    let newAttributeBindings = [];\n    for (let key in this.attrs) {\n      if (this.NON_ATTRIBUTE_BOUND_PROPS.indexOf(key) === -1 && this.attributeBindings.indexOf(key) === -1) {\n        newAttributeBindings.push(key);\n      }\n    }\n\n    set(this, 'attributeBindings', this.attributeBindings.concat(newAttributeBindings));\n  }\n});\n```\n\nNote that this approach uses a blacklist. I. e. it would process any attribute that is not mentioned in `NON_ATTRIBUTE_BOUND_PROPS` (which is a concatenated property: if you try to override it, you will instead append to it).\n\nYou can adjust this logic to use a whitelist instead.\n\n\n\n## Know more? Share!\n\nKudos to Ricardo Mendes ([@locks](https://github.com/locks)) for kind explanations of how `classNameBindings` work.\n\nIf you see an inaccuracy or have a better explanation of the matter, don't hesitate to share in the comments!\n"
    }
  }
}