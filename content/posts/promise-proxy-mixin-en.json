{
  "data": {
    "id": "promise-proxy-mixin-en",
    "type": "posts",
    "attributes": {
      "id": "promise-proxy-mixin-en",
      "title": "PromiseProxyMixin: pure Ember alternative to ember-concurrency",
      "summary": "ember-concurrency is an extremely powerful and useful addon. Yet, if your only use case is fetching or sending data, there's a lighweight alternative.",
      "created": "2017-03-07T00:00:00.000Z",
      "updated": "2018-01-05T00:00:00.000Z",
      "proficiency": "beginner",
      "body": "\n<div class=\"exclamation\"></div>\n\n> This article was originally posted on Deveo blog.\n> \n> When Deveo was acquired by Perforce, Deveo blog was turned down.\n\n\n\n[ember-concurrency](http://ember-concurrency.com) is an exceptionally powerful add-on with numerous use cases.\n\nThe most common use case though is simply fetching or submitting data. You may be hesitant to include `ember-concurrency` into your app only for this use case.\n\nThe matter is that Ember has all the necessary pieces included for implementing this kind of data fetching with simplicity and efficiency while staying true to the Ember way.\n\n\n\n## Example use case\n\nLet me demonstrate on a simple example. We are going to fetch the remaining number of available requests from GitHub API:\n\n    GET http://api.github.com/rate_limit\n\nI've chosen this particular API endpoint because it's the only one that GitHub doesn't rate-limit. :trollface:\n\nLet's implement a data fetching method:\n\n```js\nimport Controller from '@ember/controller'\nimport fetch from 'fetch'\n\nController.extend({\n  _fetchGitHubRate () {\n    return fetch('https://api.github.com/rate_limit')\n      .then(response => response.json());\n  },\n});\n```\n\nI'm using [ember-fetch](https://github.com/ember-cli/ember-fetch), but it can be anything that returns a promise, for example, the [ember-ajax](https://github.com/ember-cli/ember-ajax) service.\n\nAnd it can happen not only in a controller, but in any other Ember entity: component, service, model, etc.\n\n\n\n## Enter `PromiseProxyMixin`\n\nYou've probably heard an opinion that returning a promise from a computed property is a bad idea. Well, with [PromiseProxyMixin](https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin) that's not true.\n\nLet's create an Ember Object enhanced with `PromiseProxyMixin`. You can do this on the root level of your module:\n\n```js\nimport EmberObject from '@ember/object'\nimport PromiseProxyMixin from '@ember/object/promise-proxy-mixin'\n\nconst PromiseObject = EmberObject.extend(PromiseProxyMixin);\n```\n\nNow we can wrap the promise into `PromiseObject`. Make sure to create two distinct computed properties (CPs):\n\n```js\n// This CP returns a simple promise\ngitHubRatePromise: computed(function () {\n  return this._fetchGitHubRate();\n}),\n\n// This CP wraps the promise with with `PromiseObject` \ngitHubRateProxy: computed('gitHubRatePromise', function () {\n  const promise = this.get('gitHubRatePromise');\n  return promise && PromiseObject.create({promise});\n}),\n```\n\nNote the `promise &&` part. We don't want the promise proxy to be created when the promise does not exist because it would crash in that case.\n\n\n\n## Accessing the content of a promise\n\nThe API endpoint we're accessing returns the data in this format (fragment shown):\n\n```js\n{\n  \"resources\": {\n    \"core\": {\n      \"limit\": 60,\n      \"remaining\": 60,\n      \"reset\": 1486831110\n    },\n}\n```\n\nThis hash will become available in the template as `gitHubRateProxy.content`. You can work with this property normally, as shown below:\n\n```js\n  gitHubRate:          reads('gitHubRateProxy.content'),\n  gitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\n  gitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n```\n\nWhile the promise is not resolved, those properties will be `undefined`. Make sure to account for that when you use them downstream:\n\n```js\n  gitHubRatePercentage: computed('gitHubRateRemaining', 'gitHubRateLimit', function () {\n    const gitHubRateRemaining = this.get('gitHubRateRemaining');\n    const gitHubRateLimit     = this.get('gitHubRateLimit');\n    \n    // We don't want a `NaN`!\n    if (gitHubRateRemaining == null || gitHubRateLimit == null) return;\n    \n    const percentage  = Math.round(gitHubRateRemaining / gitHubRateLimit * 100);\n    \n    return `${percentage}%`;\n  }),\n```\n\nNow you can simply use these properties in your template!\n\n```handlebars\nYour GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n```\n\n\n\n## How it works\n\nInitially, the `gitHubRatePromise` CP is not consumed, and the request isn't made.\n\nWhen the template is rendered, the `gitHubRateRemaining` computed property is accessed. This CP depends on `gitHubRateProxy`. The `gitHubRateProxy` in turn reads `gitHubRatePromise`.\n\nWhen the `gitHubRatePromise` computed property is accessed for the first time, it calls the data fetching method and returns the promise.\n\nThis promise is cached, so when it is accessed again, the computed property returns the same promise, and duplicate requests are not performed. Essentially, it implements a pattern that `ember-concurrency` calls `drop`!\n\nThe promise is wrapped into the `PromiseObject` available as `gitHubRateProxy`. When the promise resolves, its return value becomes available as `gitHubRateProxy.content`.\n\nNote that this approach is declarative. I. e. you don't have to do this:\n\n```js\ndidInsertElement () {\n  this._super()\n  this.get('fetchGitHubRateTask').perform()\n}\n```\n\n\n\n## Accounting for a pending promise\n\nBefore the promise is resolved, `gitHubRateProxy.content` will be `undefined`. This means that while the promise is pending, the user will see nothing. Let's fix that.\n\n`PromiseProxyMixin` exposes the `gitHubRateProxy.isPending` property. We can read it in our template:\n\n```handlebars\n{{#if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\nDoing this feels quite natural. Turns out, returning promises from computed properties isn't that bad! :wink:\n\n\n\n## Accounting for a rejected promise\n\nYou might have already noticed a problem in this example: if a promise is rejected (due to a network hiccup, for example), it's rejected value will be cached forever. This is where `ember-concurrency` shines: it lets you restart a rejected task with very little boilerplate code.\n\nWe can restart our promise with a few extra lines of code. The trick is to overwrite the `gitHubRatePromise` computed property with a static promise:\n\n```js\n  actions: {\n    refetchGitHubRate () {\n      this.set('gitHubRatePromise', this._fetchGitHubRate());\n    }\n  },\n```\n\nCalling this action will start a new network request, put its promise into `gitHubRatePromise` and force all dependent computed properties to recalculate! `gitHubRateProxy.isRejected` will be true when the promise is rejected. `gitHubRateProxy.reason` will contain the rejection message. Let's do it:\n\n```handlebars\n{{#if gitHubRateProxy.isRejected}}\n\n  Failed to retrieve GitHub rate limit.<br>\n    \n  Reason: {{gitHubRateProxy.reason}}<br>\n    \n  <a href {{action 'refetchGitHubRate'}}>\n    Retry\n  </a>\n    \n{{else if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\n\n## Demo\n\nSee the complete code sample and try it in action [on Ember Twiddle](https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs):\n<iframe src=\"https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?fullScreen=true\" style=\"width: 100%; height: 500px; border: 2px solid biege;\"></iframe><br>\n\n[Here](https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs) you can find the `ember-concurrency` variant for comparison.\n\n\n\n## Keeping the logic on a service for reusability\n\nIf you have the described logic on a component and render the component in two distinct routes, it will redownload the data every time the user switches routes.\n\nThis is likely not desirable. Instead, you want the response to be cached globally, it should be redownloaded only when explicitly told to.\n\nThe solution to this is simple: move the logic into a service. It's very convenient to subclass `ember-ajax` and enhance it with custom methods and computed properties.\n\n\n\n## `Ember.ObjectProxy` is not necessary\n\nNote that official [PromiseProxyMixin](https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin) docs suggest using `Ember.ObjectProxy`. However, it is doing some black magic with the only purpose of which is to shorten this path:\n\n    gitHubRateProxy.content.resources.core.remaining\n\nby removing the `.content` segment so that it looks like this:\n\n    gitHubRateProxy.resources.core.remaining\n\nNaturally, this black magic doesn't work for arrays. For arrays, you have to use `Ember.ArrayProxy` which of course doesn't work with objects. And if your promise returns a class instance rather than a hash (POJO), you can use neither of them.\n\n`Ember.Object` is universal. Having this extra `.content` segment is a tiny price to pay for the straightforwardness it offers. I believe, `ObjectProxy` and `ArrayProxy` are the remnants of the bygone era of `ObjectController` and `ArrayController`.\n\n\n\n## Neither are `ember-deferred-content` and `ember-async-button`\n\nThese two addons approach promise wrapping on template level. They offer funky template APIs without offering anything that the described approach does not offer. \n\nCompare these:\n\n```handlebars\n{{#if gitHubRateProxy.isRejected}}\n\n  Failed to retrieve GitHub rate limit.<br>\n    \n  Reason: {{gitHubRateProxy.reason}}<br>\n    \n  <a href {{action 'refetchGitHubRate'}}>\n    Retry\n  </a>\n    \n{{else if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\n```handlebars\n{{#deferred-content gitHubRatePromise as |d|}}\n  {{#d.pending}}\n    Retrieving GitHub rate limit...\n  {{/d.pending}}\n\n  {{#d.fulfilled as |gitHubRate|}}\n    Your GitHub rate limit:\n\n    {{gitHubRate.resources.core.remaining}}\n\n    ({{multiply\n      (divide gitHubRate.resources.core.remaining gitHubRate.resources.core.limit)\n      100\n    }}%)\n  {{/d.fulfilled}}\n\n  {{#d.rejected as |reason|}}\n    Failed to retrieve GitHub rate limit.<br>\n      \n    Reason: {{reason}}<br>\n      \n    <a href {{action 'refetchGitHubRate'}}>\n      Retry\n    </a>\n  {{/d.rejected}}\n{{/deferred-content}}\n```\n\nNote how `ember-deferred-content` forces you to calculate percentage on the template level.\n\n\n\n## I'm not advocating against `ember-concurrency`\n\nThe main purpose of this article is to show you a pattern and make you give it a little thought. The pattern is fully legit and I'm using it whenever I don't feel like including `ember-concurrency` into my project.\n\nThere are at least two reasons to do this:\n\n* you care for your distribution size too much, and\n* you want to keep it simple and avoid extra layers of unnecessary abstraction and complexity\n\nIf you're already familiar with `ember-concurrency` and have it included in your project, there's no reason not to employ it for this use case. It may save you some typing:\n\n```js\ngitHubRateTask: task(function * () {\n  return yield this._fetchGitHubRate();\n}).restartable().on('didInsertElement')\n\ngitHubRate:          reads('gitHubRateTask.last.value'),\ngitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\ngitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n\n// If we don't do this, the request will not be made. Smells imperative. :(\ndidInsertElement () {\n  this._super()\n  this.get('fetchGitHubRateTask').perform()\n}\n```\n\n[Here](https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs)'s the link to th full `ember-concurrency` example again.\n\n\n\n## Accessing the previous response after the request is repeated and fails\n\nConsider this use case. We're polling the backend every second and we want the last available result to be displayed at all times.\n\n`ember-concurrency` offers access to the last resolution and rejection values even after the task has been restarted:\n\n```handlebars\n{{gitHubRateTask.lastSuccessful.value}}\n```\n\nIf we do the same with the `PromiseProxyMixin` approach, the value on the page will be flashing every second. This is because the promise gets overwritten every second, and the previous resolution value becomes unavailable.\n\nA quick solution would be to add `.then(result => this.set('result', result))` to the promise, so that the resolved value gets extracted from the promise and stored separately.\n\nThis is a valid solution, but I don't like it for its imperativeness. Instead, consider this CP macro:\n\n```js\nfunction cachingMacro (key) {\n  let cache\n\n  return computed(key, function () {\n    const value = this.get(key)\n    \n    return value == null\n      ? cache\n      : cache = value\n  })\n}\n```\n\nIt can be used like this: \n\n```js\ngitHubRate:          cachingMacro('gitHubRateProxy.content'),\ngitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\ngitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n```\n\nNow, when the promise is overwritten with another promise that rejects, `gitHubRate` will still contain the resolved value of the first promise.\n\nOr you can use `ember-concurrency` after all. :grimacing:\n\n\n\n## Tell me what you think\n\nUse the comments below to share your impressions, objections, and ideas. The most valuable part of an article is always the discussion that follows!"
    }
  }
}