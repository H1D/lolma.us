<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
<meta name="lolma-us/config/environment" content="%7B%22modulePrefix%22%3A%22lolma-us%22%2C%22podModulePrefix%22%3A%22lolma-us/pods%22%2C%22environment%22%3A%22production%22%2C%22rootURL%22%3A%22/%22%2C%22locationType%22%3A%22auto%22%2C%22envVars%22%3A%7B%22LMS_GITHUB_CLIENT_ID%22%3A%224da52fd7973591d437ea%22%2C%22LMS_ROLLBAR_CLIENT_ID%22%3A%224c6c03ad77a74b16bc4bb6a7b4726bde%22%2C%22LMS_HOST%22%3A%22https%3A//lolma.us%22%2C%22LMS_GATEKEEPER_URL%22%3A%22https%3A//lolma-us-prod.herokuapp.com%22%7D%2C%22EmberENV%22%3A%7B%22FEATURES%22%3A%7B%7D%2C%22EXTEND_PROTOTYPES%22%3A%7B%22Date%22%3Afalse%7D%7D%2C%22APP%22%3A%7B%22name%22%3A%22lolma-us%22%2C%22version%22%3A%220.0.0+1b57ddef%22%7D%2C%22emberRollbarClient%22%3A%7B%22enabled%22%3Atrue%2C%22accessToken%22%3A%224c6c03ad77a74b16bc4bb6a7b4726bde%22%2C%22verbose%22%3Atrue%2C%22captureUncaught%22%3Atrue%2C%22captureUnhandledRejections%22%3Atrue%2C%22payload%22%3A%7B%22environment%22%3A%22production%22%2C%22client%22%3A%7B%22javascript%22%3A%7B%22source_map_enabled%22%3Atrue%2C%22code_version%22%3A%220.0.0+1b57dde%22%2C%22guess_uncaught_frames%22%3Atrue%7D%7D%7D%7D%2C%22i18n%22%3A%7B%22defaultLocale%22%3A%22en%22%7D%2C%22fastboot%22%3A%7B%22hostWhitelist%22%3A%5B%22/%22%2C%22http%3A//127.0.0.1%3A8081%22%5D%7D%2C%22torii%22%3A%7B%22providers%22%3A%7B%22github-oauth2%22%3A%7B%22apiKey%22%3A%224da52fd7973591d437ea%22%2C%22scope%22%3A%22public_repo%22%7D%7D%7D%2C%22moment%22%3A%7B%22includeLocales%22%3A%5B%22ru%22%5D%7D%2C%22metricsAdapters%22%3A%5B%7B%22name%22%3A%22GoogleAnalytics%22%2C%22environments%22%3A%5B%22development%22%2C%22production%22%5D%2C%22config%22%3A%7B%22id%22%3A%22UA-77566978-1%22%2C%22sendHitTask%22%3Atrue%7D%7D%5D%2C%22disqus%22%3A%7B%22shortname%22%3A%22lolmaus%22%7D%2C%22LMS_GITHUB_CLIENT_ID%22%3A%224da52fd7973591d437ea%22%2C%22LMS_ROLLBAR_CLIENT_ID%22%3A%224c6c03ad77a74b16bc4bb6a7b4726bde%22%2C%22LMS_HOST%22%3A%22https%3A//lolma.us%22%2C%22LMS_GATEKEEPER_URL%22%3A%22https%3A//lolma-us-prod.herokuapp.com%22%2C%22exportApplicationGlobal%22%3Afalse%7D" />
<!-- EMBER_CLI_FASTBOOT_TITLE -->  <meta name="ember-cli-head-start">
<title>Возвращайте `RSVP.hash()` из `model`-хуков ваших маршрутов! | Блог | Андрей Михайлов (lolmaus)</title>
<meta property="og:title" content="Возвращайте `RSVP.hash()` из `model`-хуков ваших маршрутов!">

<!---->
  <meta property="og:locale" content="ru">
  <link rel="alternate" type="application/rss+xml" href="https://lolma.us/rss_ru.xml">

  <meta property="og:description" content="Принято считать, что возврат хэша из `model`-хука — это плохая практика. Я убежден, что это не так! Я всегда возвращаю хэш по определенной схеме, и нахожу это чрезвычайно удобным.">

<meta property="og:image" content="https://lolma.us/favicon.jpg">

<meta property="og:type" content="article">

  <link rel="canonical" href="https://lolma.us/ru/blog/route-model-hook-rsvp-hash/">
  <meta property="og:url" content="https://lolma.us/ru/blog/route-model-hook-rsvp-hash/">
  <meta property="article:published_time" content="2016-12-08T00:00:00.000Z">
  <meta property="article:author" content="https://lolma.us/ru/">

<!---->
<!---->
  <script type="application/ld+json">{"@context":"http://schema.org","@graph":[{"@type":"WebSite","image":"https://lolma.us/favicon.jpg","author":{"@type":"Person","name":"Andrey Mikhaylov","givenName":"Andrey","familyName":"Mikhaylov","additionalName":"lolmaus","email":"mailto:lolmaus@gmail.com","image":"https://lolma.us/favicon.jpg","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}},"brand":{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},"homeLocation":{"@type":"Place","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}}},"jobTitle":["Frontend developer","EmberJS developer"],"memberOf":{"@type":"Organization","logo":"https://lolma.us/images/linked-data/perforce-logo.png","url":"https://www.perforce.com/","name":"Perforce","brand":[{"@type":"Brand","name":"Helix Core","logo":"https://lolma.us/images/linked-data/helix-core-logo-8c5164957fa78647968b2db6e0893567.png","url":"https://www.perforce.com/products/helix-core","description":"Version Control + Swarm Code Review &amp; Collaboration"},{"@type":"Brand","name":"Hansoft","logo":"https://lolma.us/images/linked-data/hansoft-logo-7658d48e82acda65c2106b2eba082e57.png","url":"https://hansoft.com/","description":"Agile Project &amp; Product Management Solution"},{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},{"@type":"Brand","name":"Helix ALM","logo":"https://lolma.us/images/linked-data/helix-alm-logo-9b37cab7b9b913e82c6b38a99f43a4e2.png","url":"https://www.perforce.com/products/helix-alm","description":"Flexible, End-to-End Application Lifecycle Management"}]},"nationality":{"@type":"Country","name":"Russia","alternateName":"Russian Federation"}},"accessMode":"textual","inLanguage":"ru","audience":{"@type":"Audience","audienceType":["developers","web developers","javascript developers","js developers","ember developers","emberjs developers"]},"license":{"@type":"CreativeWork","name":"Creative Commons Attribution 4.0 International","alternateName":"CC BY 4.0","url":"https://creativecommons.org/licenses/by/4.0/","description":"You are free to: Share — copy and redistribute the material in any medium or format; Adapt — remix, transform, and build upon the material for any purpose, even commercially). This license is acceptable for Free Cultural Works. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits."}},{"@type":"Blog","author":{"@type":"Person","name":"Andrey Mikhaylov","givenName":"Andrey","familyName":"Mikhaylov","additionalName":"lolmaus","email":"mailto:lolmaus@gmail.com","image":"https://lolma.us/favicon.jpg","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}},"brand":{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},"homeLocation":{"@type":"Place","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}}},"jobTitle":["Frontend developer","EmberJS developer"],"memberOf":{"@type":"Organization","logo":"https://lolma.us/images/linked-data/perforce-logo.png","url":"https://www.perforce.com/","name":"Perforce","brand":[{"@type":"Brand","name":"Helix Core","logo":"https://lolma.us/images/linked-data/helix-core-logo-8c5164957fa78647968b2db6e0893567.png","url":"https://www.perforce.com/products/helix-core","description":"Version Control + Swarm Code Review &amp; Collaboration"},{"@type":"Brand","name":"Hansoft","logo":"https://lolma.us/images/linked-data/hansoft-logo-7658d48e82acda65c2106b2eba082e57.png","url":"https://hansoft.com/","description":"Agile Project &amp; Product Management Solution"},{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},{"@type":"Brand","name":"Helix ALM","logo":"https://lolma.us/images/linked-data/helix-alm-logo-9b37cab7b9b913e82c6b38a99f43a4e2.png","url":"https://www.perforce.com/products/helix-alm","description":"Flexible, End-to-End Application Lifecycle Management"}]},"nationality":{"@type":"Country","name":"Russia","alternateName":"Russian Federation"}},"accessMode":"textual","inLanguage":"ru","audience":{"@type":"Audience","audienceType":["developers","web developers","javascript developers","js developers","ember developers","emberjs developers"]},"license":{"@type":"CreativeWork","name":"Creative Commons Attribution 4.0 International","alternateName":"CC BY 4.0","url":"https://creativecommons.org/licenses/by/4.0/","description":"You are free to: Share — copy and redistribute the material in any medium or format; Adapt — remix, transform, and build upon the material for any purpose, even commercially). This license is acceptable for Free Cultural Works. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits."},"name":"Блог Андрея Михайлова (lolmaus)","description":"Заметки о вэб-разработке, в основном о JavaScript и EmberJS","url":"https://lolma.us/ru/blog/","keywords":["development","web development","webdev","ember","emberjs","js","javascript","frontend"]},{"@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://lolma.us/ru/blog/","name":"Блог"}},{"@type":"ListItem","position":2,"item":{"@id":"https://lolma.us/ru/blog/route-model-hook-rsvp-hash/","name":"Возвращайте `RSVP.hash()` из `model`-хуков ваших маршрутов!"}}]},{"@type":"TechArticle","author":{"@type":"Person","name":"Andrey Mikhaylov","givenName":"Andrey","familyName":"Mikhaylov","additionalName":"lolmaus","email":"mailto:lolmaus@gmail.com","image":"https://lolma.us/favicon.jpg","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}},"brand":{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},"homeLocation":{"@type":"Place","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}}},"jobTitle":["Frontend developer","EmberJS developer"],"memberOf":{"@type":"Organization","logo":"https://lolma.us/images/linked-data/perforce-logo.png","url":"https://www.perforce.com/","name":"Perforce","brand":[{"@type":"Brand","name":"Helix Core","logo":"https://lolma.us/images/linked-data/helix-core-logo-8c5164957fa78647968b2db6e0893567.png","url":"https://www.perforce.com/products/helix-core","description":"Version Control + Swarm Code Review &amp; Collaboration"},{"@type":"Brand","name":"Hansoft","logo":"https://lolma.us/images/linked-data/hansoft-logo-7658d48e82acda65c2106b2eba082e57.png","url":"https://hansoft.com/","description":"Agile Project &amp; Product Management Solution"},{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},{"@type":"Brand","name":"Helix ALM","logo":"https://lolma.us/images/linked-data/helix-alm-logo-9b37cab7b9b913e82c6b38a99f43a4e2.png","url":"https://www.perforce.com/products/helix-alm","description":"Flexible, End-to-End Application Lifecycle Management"}]},"nationality":{"@type":"Country","name":"Russia","alternateName":"Russian Federation"}},"accessMode":"textual","inLanguage":"ru","audience":{"@type":"Audience","audienceType":["developers","web developers","javascript developers","js developers","ember developers","emberjs developers"]},"license":{"@type":"CreativeWork","name":"Creative Commons Attribution 4.0 International","alternateName":"CC BY 4.0","url":"https://creativecommons.org/licenses/by/4.0/","description":"You are free to: Share — copy and redistribute the material in any medium or format; Adapt — remix, transform, and build upon the material for any purpose, even commercially). This license is acceptable for Free Cultural Works. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits."},"headline":"Возвращайте `RSVP.hash()` из `model`-хуков ваших маршрутов!","description":"Принято считать, что возврат хэша из `model`-хука — это плохая практика. Я убежден, что это не так! Я всегда возвращаю хэш по определенной схеме, и нахожу это чрезвычайно удобным.","image":"https://lolma.us/favicon.jpg","datePublished":"2016-12-08T00:00:00.000Z","proficiency":"beginner","mainEntityOfPage":{"@type":"WebPage","@id":"https://lolma.us/ru/blog/route-model-hook-rsvp-hash/"}}]}</script>
<meta name="ember-cli-head-end">


    <link integrity="" rel="stylesheet" href="/assets/vendor-10c46aeeb15514da80ccb4d3f41b4526.css">
    <link integrity="" rel="stylesheet" href="/assets/lolma-us-7bea756b2ad871bcdb1fb19ad6ecdba3.css">
    <link href="https://fonts.googleapis.com/css?family=PT+Sans+Caption|Merriweather:400,400i,700&amp;subset=cyrillic" rel="stylesheet">

    
  <link rel="yandex-tableau-widget" href="/yandex-browser-manifest.json">
<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="228x228" href="/coast-228x228.png">
<link rel="manifest" href="/manifest.json">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#fff">
<meta name="application-name">
<meta name="msapplication-TileColor" content="#fff">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 1)" href="/apple-touch-startup-image-320x460.png">
<link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-640x920.png">
<link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-640x1096.png">
<link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-750x1294.png">
<link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 3)" href="/apple-touch-startup-image-1182x2208.png">
<link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 3)" href="/apple-touch-startup-image-1242x2148.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 1)" href="/apple-touch-startup-image-748x1024.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 1)" href="/apple-touch-startup-image-768x1004.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-1496x2048.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-1536x2008.png">
</head>
  <body>
    <div id="ember3104" class="ember-view"><!---->

<div class="route-locale">

  <input type="checkbox" id="route-locale-menuToggler" class="route-locale-menuToggler ember-checkbox ember-view">

  <label for="route-locale-menuToggler" class="route-locale-burger">
    <svg height="25" viewBox="0 0 25 25" width="25" xmlns="http://www.w3.org/2000/svg" class="route-locale-burger-icon"><title/><path d="M0 2h25v4H0V2zm0 8h25v4H0v-4zm0 8h25v4H0v-4z" fill="#000" fill-rule="evenodd"/></svg>
  </label>

  <label for="route-locale-menuToggler" class="route-locale-backdrop"></label>



  <div id="ember3108" class="route-locale-menu sideMenu ember-view"><div class="route-locale-menu-greeting">
  Ты сегодня лучше всех!
  <span class="route-locale-menu-greeting-emoji">😎</span>
</div>

<div class="route-locale-menu-items">
<!---->
    <a href="/ru" id="ember3113" class="route-locale-menu-item _resume ember-view">Резюме</a>

  <a href="https://github.com/lolmaus/lolma.us" class="route-locale-menu-item _source -no-icon">
    Исходник на GitHub
    <span class="externalLink"></span>
  </a>

<a href="/en/blog/route-model-hook-rsvp-hash" id="ember3122" class="route-locale-menu-item _locale ember-view">    Switch to English
</a></div></div>



  <div class="route-locale-content">
    <div class="route-blog">


<div id="ember3128" class="secTion ember-view"><div class="secTion-inner ">
      <div class="route-blog-sidebar">
      <div class="route-blog-sidebar-section _avatar">
        <img src="/favicon.jpg" alt="Андрей Михайлов" width="512" height="512" class="route-blog-sidebar-avatar">
      </div>

      <div class="route-blog-sidebar-section _content">
        <h2 class="route-blog-title">
          Андрей Михайлов
          @lolmaus
        </h2>

        <div class="route-blog-subtitle">
          фронтенд&#8209;разработчик, EmberJS&#8209;энтузиаст
        </div>

        <div id="ember3141" class="route-blogIndex-menu horizontalMenu ember-view"><div class="horizontalMenu-item _blog">
  <a href="/ru/blog" id="ember3142" class="horizontalMenu-item-link active ember-view">Блог</a>
</div>


<div class="horizontalMenu-item _resume">
  <a href="/ru" id="ember3147" class="horizontalMenu-item-link ember-view">Резюме</a>
</div>


<div class="horizontalMenu-item _source">
  <a href="https://github.com/lolmaus/lolma.us" class="horizontalMenu-item-link -no-icon -has-inner">
    <span class="horizontalMenu-item-link-inner">Исходник на GitHub</span><span class="externalLink"></span>
  </a>
</div>


<div class="horizontalMenu-item _locale">
<a href="/en/blog/route-model-hook-rsvp-hash" id="ember3156" class="horizontalMenu-item-link ember-view">    Switch to English
</a></div></div>
      </div>
      
      <div class="route-blog-sidebar-section _bottom">

        <a href="https://creativecommons.org/licenses/by/4.0/" class="route-blog-sidebar-section-bottom-link -no-icon">
          <svg version="1" xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="5.5 -3.5 64 64" class="route-blog-sidebar-section-bottom-icon _cc" alt="Лицензия Creative Commons 4.0 Attribution" title="Лицензия Creative Commons 4.0 Attribution"><circle fill="#FFF" cx="37.637" cy="28.806" r="28.276"/><path d="M37.443-3.5c8.988 0 16.57 3.085 22.742 9.257C66.393 11.967 69.5 19.548 69.5 28.5c0 8.991-3.049 16.476-9.145 22.456-6.476 6.363-14.113 9.544-22.912 9.544-8.649 0-16.153-3.144-22.514-9.43C8.644 44.784 5.5 37.262 5.5 28.5c0-8.761 3.144-16.342 9.429-22.742C21.101-.415 28.604-3.5 37.443-3.5zm.114 5.772c-7.276 0-13.428 2.553-18.457 7.657-5.22 5.334-7.829 11.525-7.829 18.572 0 7.086 2.59 13.22 7.77 18.398 5.181 5.182 11.352 7.771 18.514 7.771 7.123 0 13.334-2.607 18.629-7.828 5.029-4.838 7.543-10.952 7.543-18.343 0-7.276-2.553-13.465-7.656-18.571-5.104-5.104-11.276-7.656-18.514-7.656zm8.572 18.285v13.085h-3.656v15.542h-9.944V33.643h-3.656V20.557c0-.572.2-1.057.599-1.457.401-.399.887-.6 1.457-.6h13.144c.533 0 1.01.2 1.428.6.417.4.628.886.628 1.457zm-13.087-8.228c0-3.008 1.485-4.514 4.458-4.514s4.457 1.504 4.457 4.514c0 2.971-1.486 4.457-4.457 4.457s-4.458-1.486-4.458-4.457z"/></svg>
        </a>

        <a href="https://lolma.us/rss_ru.xml" class="route-blog-sidebar-section-bottom-link -no-icon">
          <svg xmlns="http://www.w3.org/2000/svg" height="49.25" viewBox="0 0 49.249999 49.249999" width="49.25" class="route-blog-sidebar-section-bottom-icon _rss" alt="RSS" title="RSS"><path d="M24.625 0C11.025 0 0 11.025 0 24.625 0 38.227 11.024 49.25 24.625 49.25c13.602 0 24.625-11.023 24.625-24.625C49.25 11.025 38.226 0 24.625 0zm-7.637 35.735a3.238 3.238 0 1 1 .002-6.476 3.238 3.238 0 0 1-.002 6.476zm8.123.021c0-3.057-1.182-5.928-3.33-8.082a11.247 11.247 0 0 0-8.028-3.342v-4.674c8.84 0 16.03 7.223 16.03 16.098h-4.672zm8.256.004c0-10.867-8.795-19.711-19.606-19.711v-4.676c13.387 0 24.28 10.942 24.28 24.387h-4.674z"/></svg>
        </a>
      </div>
      
    </div>

</div></div>

<div id="ember3169" class="route-blog-content secTion ember-view"><div class="secTion-inner route-blog-content-inner">
      <div class="route-blogPost">

  <a href="/ru/blog" id="ember3171" class="route-blogPost-back active ember-view">← В блог</a>

  <div id="ember3176" class="route-blogPost-post blogPost -full ember-view">  <h1 id="ember3177" class="blogPost-title ember-view"><p>Возвращайте <code>RSVP.hash()</code> из <code>model</code>-хуков ваших маршрутов!</p>
</h1>



<p class="blogPost-date">
  8-го декабря 2016

<!---->
</p>



  <div id="ember3178" class="blogPost-summary ember-view"><p>Принято считать, что возврат хэша из <code>model</code>-хука — это плохая практика. Я убежден, что это не так! Я всегда возвращаю хэш по определенной схеме, и нахожу это чрезвычайно удобным.</p>
</div>



  <div id="ember3179" class="blogPost-body ember-view"><h2 id="почему-это-считается-плохой-практикой" class="headingWithLink"><a href="#почему-это-считается-плохой-практикой" class="headingWithLink-link">#</a>Почему это считается плохой практикой?</h2>
<p>Сам я никогда так не считал, поэтому давайте посмотрим, что об этом думает Ember-разработчик поумнее меня.</p>
<p>Sam Selikoff, героический автор <a href="http://www.ember-cli-mirage.com/">Mirage</a>, <a href="https://medium.com/@sam.selikoff/because-returning-a-single-domain-object-from-the-route-is-the-ember-pattern-the-very-name-of-the-94c4abf4ad58#.b6gzydbvt">в этом посте</a>высказался категорически против возврата хэша из <code>model</code>-хуков.</p>
<p>Хотя я определенно следую примеру Сэма в вопросах паттернов Ember, по данному конкретному вопросу смею решительно не согласиться.</p>
<p>Вот некоторые из его аргументов в моем кратком изложении. Обязательно прочтите оригинальный пост!</p>
<ul>
<li>Само имя хука — <code>model</code> — предполагает возврат одной сущности.</li>
<li>Необходиость возврата более одной сущности — это признак неудачно спроектированного <a href="https://ru.wikipedia.org/wiki/ER-модель_данных">ERM</a>.</li>
<li>Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель, имеющую relationships с необходимыми вам моделями. Такая связующая модель будет одной сущностью, представлющей определенную комбинацию свзяанных моделей.</li>
<li>Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте. Выберите самую важную из них и грузите ее, а остальные загружайте на уровне контроллера/компонента после первоначального рендеринга страницы.</li>
<li>В Rails, контроллеры должны создавать только одну сущность.</li>
</ul>
<p>Давайте посмотрим.</p>
<blockquote>
  <p>Само имя хука — <code>model</code> — предполагает возврат одной сущности.</p>
</blockquote>
<p>Имя метода не является для меня определяющим фактором. Прежде всего, в вэб-разработке понятие "модель" является широким. В контексте слоя модели из MVC, такого как Ember Data, "модель" означает класс, представляющий ресурс, и использующийся для создания записей-инстансов данного ресурса. Однако вне контекста MVC, "модель" -- это просто ваши данные, и они могут быть любыми, от простой строки до сложной, произвольно организованной JSON-подобной структуры.</p>
<p>Кроме того, Сэм не выступает против возврата массива из <code>model</code>-хука, несмотря на то, что название хука — не <code>models</code>.</p>
<blockquote>
  <p>Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель.</p>
  <p>Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте.</p>
</blockquote>
<p>Я нахожу рекомендацию рефакторить ERM так, чтобы каждый маршрут был представлен одной сущностью, идеалистической и наивной.</p>
<p>Это просто не всегда возможно. Очень часто приложение содержит маршруты, отображающие несколько самостоятельных, никак не связанных между собой моделей. При этом отображать страницу без некоторых из них -- бессмысленно с точки зрения бизнес-логики приложения.</p>
<p>Даже если ваши модели могут быть разумно объединены под связующей моделью, вы скорее всего столкнетесь с тем, что отрефакторить бэкенд затруднительно или вовсе невозможно. Например, у вас нет доступа к кодовой базе бэкенда или права вносить в нее изменения.</p>
<p>Можно было бы ввести связующую модель только на стороне фронтенда. В некоторых сложных случаях это оправдано (<a href="http://intercom.lolma.us/dublin/">пример</a>). Однако цена высока: ERM фронтенда и бэкенда начнут отличаться. Я считаю, что идти этим путем просто ради отказа от возврата хэша -- это бесмысленный расход ресурсов.</p>
<p>Даже если вы можете синхронизировать рефакторинг ERM на фронте и бэке, все равно это ужасно большой объем труда. И всё ради того, чтобы избежать этого простого паттерна.</p>
<blockquote>
  <p>В Rails, контроллеры должны создавать только одну сущность.</p>
</blockquote>
<p>Сравнивать Ember с "Рельсами" -- некорректно. Хотя они оба считаются MVC-фрэймворками, устроены они очень по-разному. У Rails вообще отсутствует класс "маршрут", а на каждый REST-запрос вызывается строго один контроллер, даже если адрес обращения представляет вложенный ресурс. В Ember же маршруты -- это сущности, ответственные за загрузку данных и вызываются по цепочке.</p>
<p>Но самое главное, Сэм не называет ни одного <em>практического</em> недостатка возврата хэша. Это потому, что недостатков нет! Зато есть преимущества.</p>
<h2 id="лучший-способ-возвращать-хэш-из-model-хука" class="headingWithLink"><a href="#лучший-способ-возвращать-хэш-из-model-хука" class="headingWithLink-link">#</a>Лучший способ возвращать хэш из <code>model</code>-хука</h2>
<p>Давайте я изложу, как я это делаю, после чего посмотрим на преимущества.</p>
<p><code>model</code>-хук каждого маршрута всегда должен возвращать <code>RSVP.hash()</code>. Даже если маршрут грузит всего лишь одну сущность, из хука возвращается хэш с одним свойством.</p>
<p>Трюк в том, что <strong>каждый хэш должен расширять хэш родительского маршрута</strong>. Разумеется, за иключением верхних маршрутов, не имеющих родителей.</p>
<p>Мои <code>model</code>-хуки выглядят примерно так:</p>
<div class="code-block"><pre><code class="js language-js hljs"><span class="hljs-comment">// posts route</span>
model () {
  <span class="hljs-keyword">const</span> store = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'store'</span>)

  <span class="hljs-keyword">return</span> RSVP.hash({
    <span class="hljs-attr">posts</span>: store.findAll(<span class="hljs-string">'post'</span>),
  })
}</code></pre></div>
<div class="code-block"><pre><code class="js language-js hljs"><span class="hljs-comment">// posts.post route</span>
{
  model ({postId}) {
    <span class="hljs-keyword">const</span> store = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'store'</span>)
    <span class="hljs-keyword">const</span> model = <span class="hljs-keyword">this</span>.modelFor(<span class="hljs-string">'posts'</span>)

    <span class="hljs-keyword">return</span> RSVP.hash({
      ...model,
      <span class="hljs-attr">currentPost</span>: store.peekRecord(<span class="hljs-string">'post'</span>, postId),
    })
  }
}</code></pre></div>
<p>Оператор <code>...</code> -- это <a href="https://www.google.ru/search?q=es2015+spread+operator">spread</a>, синтаксический сахар для <code>Ember.merge</code> и <code>Object.assign</code>.</p>
<p>Маршрут <code>posts.post</code> в итоге получит такую модель:</p>
<div class="code-block"><pre><code class="js language-js hljs">{
  <span class="hljs-attr">posts</span>: [post1, post2, post3],
  <span class="hljs-attr">currentPost</span>: post2
}</code></pre></div>
<p>Давайте посмотрим, как это улучшает вашу кодовую базу!</p>
<h2 id="самоочевидный-код" class="headingWithLink"><a href="#самоочевидный-код" class="headingWithLink-link">#</a>Самоочевидный код</h2>
<p>Один из аргументов Сэма, который я не упоминал ранее, -- это что обращение к <code>model.posts</code> в шаблоне — это хуже, чем просто <code>model</code>. Я не согласен.</p>
<p>Когда я вижу <code>model</code> в шаблоне, это всегда  смущает и запутывает. Другое дело <code>model.posts</code> -- сразу очевидно, к какой сущности делается обращение.</p>
<h2 id="единообразный-доступ-к-доступным-данным-из-любого-шаблона" class="headingWithLink"><a href="#единообразный-доступ-к-доступным-данным-из-любого-шаблона" class="headingWithLink-link">#</a>Единообразный доступ к доступным данным из любого шаблона</h2>
<p>С таким подходом, свойство <code>model</code> на каждом контроллере всегда будет содержать все данные, загруженные во всех родительских маршрутах.</p>
<p>Вы можете обратиться к любым данным из любого маршрута, без необходимости "прокидывать" их вручную, используя плохие приемы вроде <code>modelFor</code> из <code>setupController</code>, лишние сервисы или связующие модели.</p>
<p>Допустим, в маршруте конкретного поста мне нужно отобразить ссылки на предыдущий и следующий пост. Вот чего я <em>не</em> буду делать для решения этой задачи:</p>
<ul>
<li>Мне не потребуется вводить связи <code>previousPost</code> и <code>nextPost</code> на модели <code>post</code>.</li>
<li>Мне не нужно вводить новую сущность -- связующую модель, которая представляет пост вместе с двумя смежными постами.</li>
<li>Мне не нужно вызывать <code>store.peekRecord</code> на уровне компонента или контроллера.</li>
<li>Мне не нужно использовать <code>setupController</code>. Я вообще считаю <code>setupController</code> дурной практикой, которая отказывается от декларативных computed properties в пользу императивщины, без нужды увеличивающей связность приложения. Есть ровно одно оправданное применение <code>setupController</code>: прокидывать ошибку в <code>error</code>-маршрут.</li>
<li>Мне не нужно вводить сервис, задача которого — выдавать посты, смежные по отношению к данному.</li>
</ul>
<p><strong>Все, что мне требуется сделать, это обратиться к <code>model.posts</code>! Мне даже не интересно, в каком именно из родительских маршрутов были загружены эти записи.</strong></p>
<div class="exclamation"></div>
<blockquote>
  <p>Обратите внимание, что я не пропагандирую предзагрузку всех постов в маршруте <code>posts</code>. В простейшем случае, загружать список постов лучше в маршруте <code>posts.index</code>. Таким образром, посестелю не придется выгружать все посты, если он зашел почитать какой-то один из них.</p>
  <p>Но очень часто вам нужно предзагрузить все записи по какой-то другой причине. Например, вы хотите отображать облако тэгов, но у бэкенда нет API тэгов и тэги -- это просто атрибут на модели поста. Или вы хотите отобразить список недавних постов на боковой панели, но ваш бэкенд не поддерживает фильтрацию и лимит по количеству. Или у вас просто не так много записей этого типа, и предзагрузка из всех -- вполне приемлемое решение.</p>
  <p>В этих случаях вы все равно предзагружаете записи. Так почему бы не воспользоваться этим с пользой?</p>
</blockquote>
<h2 id="полагаемся-на-эффективность-computed-properties" class="headingWithLink"><a href="#полагаемся-на-эффективность-computed-properties" class="headingWithLink-link">#</a>Полагаемся на эффективность computed properties</h2>
<p>Итак, я нахожусь в маршруте конкретного поста, в свойстве <code>model.posts</code> лежит список всех постов, и я хочу отобразить ссылки на предыдущий и следующий посты.</p>
<p>В этом случае достаточно накидать несложную цепочку computed properties:</p>
<div class="code-block"><pre><code class="js language-js hljs"><span class="hljs-keyword">import</span> {sort}              <span class="hljs-keyword">from</span> <span class="hljs-string">'ember-computed'</span>
<span class="hljs-keyword">import</span> sum                 <span class="hljs-keyword">from</span> <span class="hljs-string">'ember-cpm/macros/sum'</span>
<span class="hljs-keyword">import</span> indexOf             <span class="hljs-keyword">from</span> <span class="hljs-string">'make/your/own/macro'</span>
<span class="hljs-keyword">import</span> getFromArrayByIndex <span class="hljs-keyword">from</span> <span class="hljs-string">'it/is/easy/and/fun'</span>

{
  <span class="hljs-attr">sortOrder</span>:         <span class="hljs-string">'createdAd'</span>, <span class="hljs-comment">// допустим, сортировка может регулироваться пользователем</span>
  sortedPosts:       sort(<span class="hljs-string">'model.posts'</span>, <span class="hljs-string">'sortOrder'</span>),
  <span class="hljs-attr">currentPostIndex</span>:  indexOf(<span class="hljs-string">'sortedPosts'</span>, <span class="hljs-string">'model.currentPost'</span>),
  <span class="hljs-attr">nextPostIndex</span>:     sum(<span class="hljs-string">'currentPostIndex'</span>, <span class="hljs-number">1</span>),
  <span class="hljs-attr">previousPostIndex</span>: sum(<span class="hljs-string">'currentPostIndex'</span>, <span class="hljs-number">-1</span>),
  <span class="hljs-attr">nextPost</span>:          getFromArrayByIndex(<span class="hljs-string">'sortedPosts'</span>, <span class="hljs-string">'nextPostIndex'</span>),
  <span class="hljs-attr">previousPost</span>:      getFromArrayByIndex(<span class="hljs-string">'sortedPosts'</span>, <span class="hljs-string">'previousPostIndex'</span>),
}</code></pre></div>
<div class="code-block"><pre><code class="handlebars language-handlebars hljs"><span class="xml"></span><span class="hljs-template-tag">{{#<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> nextPost}}</span><span class="xml">
  </span><span class="hljs-template-variable">{{link-to (concat '← ' nextPost.title)     'posts.post' nextPost.id}}</span><span class="xml">
</span><span class="hljs-template-tag">{{/<span class="hljs-name"><span class="hljs-builtin-name">if</span></span>}}</span><span class="xml">

</span><span class="hljs-template-tag">{{#<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> previousPost}}</span><span class="xml">
  </span><span class="hljs-template-variable">{{link-to (concat previousPost.title ' →') 'posts.post' previousPost.id}}</span><span class="xml">
</span><span class="hljs-template-tag">{{/<span class="hljs-name"><span class="hljs-builtin-name">if</span></span>}}</span><span class="xml"></span></code></pre></div>
<p>Этот код декларативен, защищен от багов, насколько это вообще возможно, и понятен с первого взгляда.</p>
<p>Кроме того, он производителен: значения computed properties кэшируются, и при повторном посещении маршрута контроллеру/компоненту не потребуется вычислять значения заново. Но если состав массива изменится, они сразу же пересчитаются автоматически.</p>
<h2 id="удобная-подгрузка-связанных-данных" class="headingWithLink"><a href="#удобная-подгрузка-связанных-данных" class="headingWithLink-link">#</a>Удобная подгрузка связанных данных</h2>
<p>Если вам нужно подгрузить связанные данные, это можно сделать очень наглядным способом.</p>
<p>В этом примере подгружаются авторы поста и всех комментариев</p>
<div class="code-block"><pre><code class="js language-js hljs">{
  model ({postId}) {
    <span class="hljs-keyword">const</span> store = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'store'</span>)
    <span class="hljs-keyword">const</span> model = <span class="hljs-keyword">this</span>.modelFor(<span class="hljs-string">'posts'</span>)

    <span class="hljs-keyword">return</span> RSVP
      .hash({
        ...model,
        <span class="hljs-attr">currentPost</span>: store.peekRecord(<span class="hljs-string">'post'</span>, postId),
      })

      <span class="hljs-comment">// Пост загрузился, давая возможнось получить его автора и комменты</span>
      .then(<span class="hljs-function"><span class="hljs-params">model</span> =&gt;</span> RSVP.hash({
        ...model,
        <span class="hljs-attr">author</span>:   model.currentPost.get(<span class="hljs-string">'author'</span>),
        <span class="hljs-attr">comments</span>: model.currentPost.get(<span class="hljs-string">'comments'</span>),
      }))

      <span class="hljs-comment">// Комменты загрузились, добываем их авторов:</span>
      .then(<span class="hljs-function"><span class="hljs-params">model</span> =&gt;</span> RSVP.hash({
        ...model,
        <span class="hljs-attr">commentAuthors</span>: store.query(<span class="hljs-string">'user'</span>, {
          <span class="hljs-string">'filter[ids]'</span>: <span class="hljs-keyword">this</span>._getCommentAuthorIds(model.comments)
        })
      }))
  },

  <span class="hljs-comment">// Удобный способ получить список айдишников авторов всех комментариев</span>
  _getCommentAuthorIds (comments) {
    <span class="hljs-keyword">return</span> comments
      .map(<span class="hljs-function"><span class="hljs-params">comment</span> =&gt;</span> comment.belongsTo(<span class="hljs-string">'author'</span>).id())
      .join(<span class="hljs-string">','</span>)
  },
}</code></pre></div>
<p>Одно из возражений Сэма заключается в том, из-за этого подхода разработчики не используют должным образом цепочку связей между моделями.</p>
<p>Я полностью согласен с тем, что в большинстве случаев обращаться к записи через цепочку связей, например, <code>model.currentPost.comments[n].author</code>) — лучше, чем, скажем, получать автора каждого коммента через поиск по массиву <code>model.commentAuthors</code>.</p>
<p>Но дело в том, что хоть все авторы доступны в свойстве <code>model.commentAuthors</code>, вы по-прежнему можете обращаться к авторам через цепочку связей. <code>model.commentAuthors</code> -- это просто легкочитаемый способ подгрузить данные, и он вовсе не ограничивает вас в возможности обходить граф моделей так, как вам удобно.</p>
<h2 id="eslint-спешит-на-помощь" class="headingWithLink"><a href="#eslint-спешит-на-помощь" class="headingWithLink-link">#</a>ESLint спешит на помощь</h2>
<p>Если вы начнете использовать этот подход, то обнаружите, что JSHint спотыкается об оператор <code>...</code> и сходит с ума.</p>
<p>Это проблема не самого подхода, а использования морально устаревших инструментов.</p>
<p><code>ember install ember-eslint</code> решает эту проблему раз и навсегда. Не стоит отказываться от мощного spread-оператора из-за того, что JSHint не умеет в ES2015.</p>
<h2 id="что-вы-думаете-об-этом-подходе" class="headingWithLink"><a href="#что-вы-думаете-об-этом-подходе" class="headingWithLink-link">#</a>Что вы думаете об этом подходе?</h2>
<p>Пожалуйста, поделитесь ниже в комментариях вашим мнением по этому поводу!</p>
<p>Делает ли данный подход вашу программерскую жизнь капельку приятнее?</p>
<p>Какие у него недостатки? Можно ли их решить, или же подход изначально ущербен?</p>
</div>
</div>

<!---->
</div>

  
</div></div>


</div>

  </div>

</div></div><script type="fastboot/shoebox" id="shoebox-ember-data-store">{"types":{"cache-buster":[{"data":{"id":"buster","attributes":{"string":"61e6c79273e8a6d750b38a3ccf881b7a52a816cf9410a1af441823157101e378"},"type":"cache-busters"}}],"experience":[],"markdown-block":[],"post":[{"data":{"id":"route-model-hook-rsvp-hash-ru","attributes":{"title":"Возвращайте `RSVP.hash()` из `model`-хуков ваших маршрутов!","body":"\n\n\n## Почему это считается плохой практикой?\n\nСам я никогда так не считал, поэтому давайте посмотрим, что об этом думает Ember-разработчик поумнее меня.\n\nSam Selikoff, героический автор [Mirage](http://www.ember-cli-mirage.com/), [в этом посте](https://medium.com/@sam.selikoff/because-returning-a-single-domain-object-from-the-route-is-the-ember-pattern-the-very-name-of-the-94c4abf4ad58#.b6gzydbvt)высказался категорически против возврата хэша из `model`-хуков.\n\nХотя я определенно следую примеру Сэма в вопросах паттернов Ember, по данному конкретному вопросу смею решительно не согласиться.\n\nВот некоторые из его аргументов в моем кратком изложении. Обязательно прочтите оригинальный пост!\n\n*   Само имя хука — `model` — предполагает возврат одной сущности.\n*   Необходиость возврата более одной сущности — это признак неудачно спроектированного [ERM](https://ru.wikipedia.org/wiki/ER-модель_данных).\n*   Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель, имеющую relationships с необходимыми вам моделями. Такая связующая модель будет одной сущностью, представлющей определенную комбинацию свзяанных моделей.\n*   Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте. Выберите самую важную из них и грузите ее, а остальные загружайте на уровне контроллера/компонента после первоначального рендеринга страницы.\n*   В Rails, контроллеры должны создавать только одну сущность.\n\nДавайте посмотрим.\n\n\u003e Само имя хука — `model` — предполагает возврат одной сущности.\n\nИмя метода не является для меня определяющим фактором. Прежде всего, в вэб-разработке понятие \"модель\" является широким. В контексте слоя модели из MVC, такого как Ember Data, \"модель\" означает класс, представляющий ресурс, и использующийся для создания записей-инстансов данного ресурса. Однако вне контекста MVC, \"модель\" -- это просто ваши данные, и они могут быть любыми, от простой строки до сложной, произвольно организованной JSON-подобной структуры.\n\nКроме того, Сэм не выступает против возврата массива из `model`-хука, несмотря на то, что название хука — не `models`.\n\n\u003e Если у вас есть потребность возвращать несколько разных моделей, вам следует отрефакторить приложение, введя связующую модель.\n\u003e\n\u003e Если же модели настолько самостоятельны, что объединять их под одной сущностью не представляется разумным, то вам не следует грузить из все в маршруте.\n\nЯ нахожу рекомендацию рефакторить ERM так, чтобы каждый маршрут был представлен одной сущностью, идеалистической и наивной.\n\nЭто просто не всегда возможно. Очень часто приложение содержит маршруты, отображающие несколько самостоятельных, никак не связанных между собой моделей. При этом отображать страницу без некоторых из них -- бессмысленно с точки зрения бизнес-логики приложения.\n\nДаже если ваши модели могут быть разумно объединены под связующей моделью, вы скорее всего столкнетесь с тем, что отрефакторить бэкенд затруднительно или вовсе невозможно. Например, у вас нет доступа к кодовой базе бэкенда или права вносить в нее изменения.\n\nМожно было бы ввести связующую модель только на стороне фронтенда. В некоторых сложных случаях это оправдано ([пример](http://intercom.lolma.us/dublin/)). Однако цена высока: ERM фронтенда и бэкенда начнут отличаться. Я считаю, что идти этим путем просто ради отказа от возврата хэша -- это бесмысленный расход ресурсов.\n\nДаже если вы можете синхронизировать рефакторинг ERM на фронте и бэке, все равно это ужасно большой объем труда. И всё ради того, чтобы избежать этого простого паттерна.\n\n\u003e В Rails, контроллеры должны создавать только одну сущность.\n\nСравнивать Ember с \"Рельсами\" -- некорректно. Хотя они оба считаются MVC-фрэймворками, устроены они очень по-разному. У Rails вообще отсутствует класс \"маршрут\", а на каждый REST-запрос вызывается строго один контроллер, даже если адрес обращения представляет вложенный ресурс. В Ember же маршруты -- это сущности, ответственные за загрузку данных и вызываются по цепочке.\n\nНо самое главное, Сэм не называет ни одного *практического* недостатка возврата хэша. Это потому, что недостатков нет! Зато есть преимущества.\n\n\n## Лучший способ возвращать хэш из `model`-хука\n\nДавайте я изложу, как я это делаю, после чего посмотрим на преимущества.\n\n`model`-хук каждого маршрута всегда должен возвращать `RSVP.hash()`. Даже если маршрут грузит всего лишь одну сущность, из хука возвращается хэш с одним свойством.\n\nТрюк в том, что **каждый хэш должен расширять хэш родительского маршрута**. Разумеется, за иключением верхних маршрутов, не имеющих родителей.\n\nМои `model`-хуки выглядят примерно так:\n\n```js\n// posts route\nmodel () {\n  const store = this.get('store')\n  \n  return RSVP.hash({\n    posts: store.findAll('post'),\n  })\n}\n```\n\n```js\n// posts.post route\n{\n  model ({postId}) {\n    const store = this.get('store')\n    const model = this.modelFor('posts')\n    \n    return RSVP.hash({\n      ...model,\n      currentPost: store.peekRecord('post', postId),\n    })\n  }\n}\n```\n\nОператор `...` -- это [spread](https://www.google.ru/search?q=es2015+spread+operator), синтаксический сахар для `Ember.merge` и `Object.assign`.\n\nМаршрут `posts.post` в итоге получит такую модель:\n\n```js\n{\n  posts: [post1, post2, post3],\n  currentPost: post2\n}\n```\n\nДавайте посмотрим, как это улучшает вашу кодовую базу!\n\n\n\n## Самоочевидный код\n\nОдин из аргументов Сэма, который я не упоминал ранее, -- это что обращение к `model.posts` в шаблоне — это хуже, чем просто `model`. Я не согласен.\n\nКогда я вижу `model` в шаблоне, это всегда  смущает и запутывает. Другое дело `model.posts` -- сразу очевидно, к какой сущности делается обращение.\n\n\n\n## Единообразный доступ к доступным данным из любого шаблона\n\n\nС таким подходом, свойство `model` на каждом контроллере всегда будет содержать все данные, загруженные во всех родительских маршрутах.\n\nВы можете обратиться к любым данным из любого маршрута, без необходимости \"прокидывать\" их вручную, используя плохие приемы вроде `modelFor` из `setupController`, лишние сервисы или связующие модели.\n\nДопустим, в маршруте конкретного поста мне нужно отобразить ссылки на предыдущий и следующий пост. Вот чего я *не* буду делать для решения этой задачи:\n\n*    Мне не потребуется вводить связи `previousPost` и `nextPost` на модели `post`.\n*    Мне не нужно вводить новую сущность -- связующую модель, которая представляет пост вместе с двумя смежными постами.\n*    Мне не нужно вызывать `store.peekRecord` на уровне компонента или контроллера.\n*    Мне не нужно использовать `setupController`. Я вообще считаю `setupController` дурной практикой, которая отказывается от декларативных computed properties в пользу императивщины, без нужды увеличивающей связность приложения. Есть ровно одно оправданное применение `setupController`: прокидывать ошибку в `error`-маршрут.\n*    Мне не нужно вводить сервис, задача которого — выдавать посты, смежные по отношению к данному.\n\n**Все, что мне требуется сделать, это обратиться к `model.posts`! Мне даже не интересно, в каком именно из родительских маршрутов были загружены эти записи.**\n\n\u003cdiv class=\"exclamation\"\u003e\u003c/div\u003e\n\n\u003e Обратите внимание, что я не пропагандирую предзагрузку всех постов в маршруте `posts`. В простейшем случае, загружать список постов лучше в маршруте `posts.index`. Таким образром, посестелю не придется выгружать все посты, если он зашел почитать какой-то один из них.\n\u003e \n\u003e Но очень часто вам нужно предзагрузить все записи по какой-то другой причине. Например, вы хотите отображать облако тэгов, но у бэкенда нет API тэгов и тэги -- это просто атрибут на модели поста. Или вы хотите отобразить список недавних постов на боковой панели, но ваш бэкенд не поддерживает фильтрацию и лимит по количеству. Или у вас просто не так много записей этого типа, и предзагрузка из всех -- вполне приемлемое решение.\n\u003e \n\u003e В этих случаях вы все равно предзагружаете записи. Так почему бы не воспользоваться этим с пользой?\n\n\n\n## Полагаемся на эффективность computed properties\n\nИтак, я нахожусь в маршруте конкретного поста, в свойстве `model.posts` лежит список всех постов, и я хочу отобразить ссылки на предыдущий и следующий посты.\n\nВ этом случае достаточно накидать несложную цепочку computed properties:\n\n```js\nimport {sort}              from 'ember-computed'\nimport sum                 from 'ember-cpm/macros/sum'\nimport indexOf             from 'make/your/own/macro'\nimport getFromArrayByIndex from 'it/is/easy/and/fun'\n\n{\n  sortOrder:         'createdAd', // допустим, сортировка может регулироваться пользователем\n  sortedPosts:       sort('model.posts', 'sortOrder'),\n  currentPostIndex:  indexOf('sortedPosts', 'model.currentPost'),\n  nextPostIndex:     sum('currentPostIndex', 1),\n  previousPostIndex: sum('currentPostIndex', -1),\n  nextPost:          getFromArrayByIndex('sortedPosts', 'nextPostIndex'),\n  previousPost:      getFromArrayByIndex('sortedPosts', 'previousPostIndex'),\n}\n```\n\n```handlebars\n{{#if nextPost}}\n  {{link-to (concat '← ' nextPost.title)     'posts.post' nextPost.id}}\n{{/if}}\n\n{{#if previousPost}}\n  {{link-to (concat previousPost.title ' →') 'posts.post' previousPost.id}}\n{{/if}}\n```\n\nЭтот код декларативен, защищен от багов, насколько это вообще возможно, и понятен с первого взгляда.\n\nКроме того, он производителен: значения computed properties кэшируются, и при повторном посещении маршрута контроллеру/компоненту не потребуется вычислять значения заново. Но если состав массива изменится, они сразу же пересчитаются автоматически.\n\n\n\n## Удобная подгрузка связанных данных\n\nЕсли вам нужно подгрузить связанные данные, это можно сделать очень наглядным способом.\n\nВ этом примере подгружаются авторы поста и всех комментариев\n\n```js\n{\n  model ({postId}) {\n    const store = this.get('store')\n    const model = this.modelFor('posts')\n    \n    return RSVP\n      .hash({\n        ...model,\n        currentPost: store.peekRecord('post', postId),\n      })\n      \n      // Пост загрузился, давая возможнось получить его автора и комменты\n      .then(model =\u003e RSVP.hash({\n        ...model,\n        author:   model.currentPost.get('author'),\n        comments: model.currentPost.get('comments'),\n      }))\n      \n      // Комменты загрузились, добываем их авторов:\n      .then(model =\u003e RSVP.hash({\n        ...model,\n        commentAuthors: store.query('user', {\n          'filter[ids]': this._getCommentAuthorIds(model.comments)\n        })\n      }))\n  },\n  \n  // Удобный способ получить список айдишников авторов всех комментариев\n  _getCommentAuthorIds (comments) {\n    return comments\n      .map(comment =\u003e comment.belongsTo('author').id())\n      .join(',')\n  },\n}\n```\n\nОдно из возражений Сэма заключается в том, из-за этого подхода разработчики не используют должным образом цепочку связей между моделями.\n\nЯ полностью согласен с тем, что в большинстве случаев обращаться к записи через цепочку связей, например, `model.currentPost.comments[n].author`) — лучше, чем, скажем, получать автора каждого коммента через поиск по массиву `model.commentAuthors`.\n\nНо дело в том, что хоть все авторы доступны в свойстве `model.commentAuthors`, вы по-прежнему можете обращаться к авторам через цепочку связей. `model.commentAuthors` -- это просто легкочитаемый способ подгрузить данные, и он вовсе не ограничивает вас в возможности обходить граф моделей так, как вам удобно.\n\n\n\n## ESLint спешит на помощь\n\nЕсли вы начнете использовать этот подход, то обнаружите, что JSHint спотыкается об оператор `...` и сходит с ума.\n\nЭто проблема не самого подхода, а использования морально устаревших инструментов.\n\n`ember install ember-eslint` решает эту проблему раз и навсегда. Не стоит отказываться от мощного spread-оператора из-за того, что JSHint не умеет в ES2015.\n\n\n\n## Что вы думаете об этом подходе?\n\nПожалуйста, поделитесь ниже в комментариях вашим мнением по этому поводу!\n\nДелает ли данный подход вашу программерскую жизнь капельку приятнее?\n\nКакие у него недостатки? Можно ли их решить, или же подход изначально ущербен?\n","summary":"Принято считать, что возврат хэша из `model`-хука — это плохая практика. Я убежден, что это не так! Я всегда возвращаю хэш по определенной схеме, и нахожу это чрезвычайно удобным.","image":null,"created":"2016-12-08T00:00:00.000Z","updated":null,"hide-summary":false,"dependencies":null,"proficiency":"beginner"},"type":"posts"}}],"project-info":[],"project":[],"stackoverflow-user":[]}}</script>

    <script src="/assets/vendor-8fa103718f5228bbbf0e48134e96adcd.js" integrity="sha256-PNNj4JHm7k/vT170qeRgv+RPJpKZmN1JEiqQhed5LKg= sha512-YfbY2HN42G+vNVK15tKzxaGmwVHrPangnBAY5i38NtVF3MxdmBYx5eDd1/b5UGMbqE0CqQ6cE5LZiFKnVXvfAg==" ></script>
    <script src="/assets/lolma-us-be4b92b2e227e4641edf880f467b4f96.js" integrity="sha256-IdRe43Hzo86CxCFau0DEvc/EdTeTqKpZb4VCLtcdkyg= sha512-2oY/tj/JByJi8hKe+FV4ggaA9kOrTnE2Es6BLT3ZXKfNFCSuwdNY1pHsxewKrI4VXXVXxPr0QUdAUSDI1mOHmw==" ></script>

    
  </body>
</html>
