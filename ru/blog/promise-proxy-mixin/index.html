<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
<meta name="lolma-us/config/environment" content="%7B%22modulePrefix%22%3A%22lolma-us%22%2C%22podModulePrefix%22%3A%22lolma-us/pods%22%2C%22environment%22%3A%22production%22%2C%22rootURL%22%3A%22/%22%2C%22locationType%22%3A%22auto%22%2C%22envVars%22%3A%7B%22LMS_GITHUB_CLIENT_ID%22%3A%224da52fd7973591d437ea%22%2C%22LMS_ROLLBAR_CLIENT_ID%22%3A%224c6c03ad77a74b16bc4bb6a7b4726bde%22%2C%22LMS_HOST%22%3A%22https%3A//lolma.us%22%2C%22LMS_GATEKEEPER_URL%22%3A%22https%3A//lolma-us-prod.herokuapp.com%22%7D%2C%22EmberENV%22%3A%7B%22FEATURES%22%3A%7B%7D%2C%22EXTEND_PROTOTYPES%22%3A%7B%22Date%22%3Afalse%7D%7D%2C%22APP%22%3A%7B%22name%22%3A%22lolma-us%22%2C%22version%22%3A%220.0.0+1b57ddef%22%7D%2C%22emberRollbarClient%22%3A%7B%22enabled%22%3Atrue%2C%22accessToken%22%3A%224c6c03ad77a74b16bc4bb6a7b4726bde%22%2C%22verbose%22%3Atrue%2C%22captureUncaught%22%3Atrue%2C%22captureUnhandledRejections%22%3Atrue%2C%22payload%22%3A%7B%22environment%22%3A%22production%22%2C%22client%22%3A%7B%22javascript%22%3A%7B%22source_map_enabled%22%3Atrue%2C%22code_version%22%3A%220.0.0+1b57dde%22%2C%22guess_uncaught_frames%22%3Atrue%7D%7D%7D%7D%2C%22i18n%22%3A%7B%22defaultLocale%22%3A%22en%22%7D%2C%22fastboot%22%3A%7B%22hostWhitelist%22%3A%5B%22/%22%2C%22http%3A//127.0.0.1%3A8081%22%5D%7D%2C%22torii%22%3A%7B%22providers%22%3A%7B%22github-oauth2%22%3A%7B%22apiKey%22%3A%224da52fd7973591d437ea%22%2C%22scope%22%3A%22public_repo%22%7D%7D%7D%2C%22moment%22%3A%7B%22includeLocales%22%3A%5B%22ru%22%5D%7D%2C%22metricsAdapters%22%3A%5B%7B%22name%22%3A%22GoogleAnalytics%22%2C%22environments%22%3A%5B%22development%22%2C%22production%22%5D%2C%22config%22%3A%7B%22id%22%3A%22UA-77566978-1%22%2C%22sendHitTask%22%3Atrue%7D%7D%5D%2C%22disqus%22%3A%7B%22shortname%22%3A%22lolmaus%22%7D%2C%22LMS_GITHUB_CLIENT_ID%22%3A%224da52fd7973591d437ea%22%2C%22LMS_ROLLBAR_CLIENT_ID%22%3A%224c6c03ad77a74b16bc4bb6a7b4726bde%22%2C%22LMS_HOST%22%3A%22https%3A//lolma.us%22%2C%22LMS_GATEKEEPER_URL%22%3A%22https%3A//lolma-us-prod.herokuapp.com%22%2C%22exportApplicationGlobal%22%3Afalse%7D" />
<!-- EMBER_CLI_FASTBOOT_TITLE -->  <meta name="ember-cli-head-start">
<title>PromiseProxyMixin: нативная альтернатива ember-concurrency | Блог | Андрей Михайлов (lolmaus)</title>
<meta property="og:title" content="PromiseProxyMixin: нативная альтернатива ember-concurrency">

<!---->
  <meta property="og:locale" content="ru">
  <link rel="alternate" type="application/rss+xml" href="https://lolma.us/rss_ru.xml">

  <meta property="og:description" content="ember-concurrency — исключительно мощный и полезный аддон. Однако если ваш единственный юз-кейс — это обращаться к серверу, то взгляните на легковесную альтернативу">

<meta property="og:image" content="https://lolma.us/favicon.jpg">

<meta property="og:type" content="article">

  <link rel="canonical" href="https://lolma.us/ru/blog/promise-proxy-mixin/">
  <meta property="og:url" content="https://lolma.us/ru/blog/promise-proxy-mixin/">
  <meta property="article:published_time" content="2018-01-05T00:00:00.000Z">
  <meta property="article:author" content="https://lolma.us/ru/">

<!---->
<!---->
  <script type="application/ld+json">{"@context":"http://schema.org","@graph":[{"@type":"WebSite","image":"https://lolma.us/favicon.jpg","author":{"@type":"Person","name":"Andrey Mikhaylov","givenName":"Andrey","familyName":"Mikhaylov","additionalName":"lolmaus","email":"mailto:lolmaus@gmail.com","image":"https://lolma.us/favicon.jpg","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}},"brand":{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},"homeLocation":{"@type":"Place","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}}},"jobTitle":["Frontend developer","EmberJS developer"],"memberOf":{"@type":"Organization","logo":"https://lolma.us/images/linked-data/perforce-logo.png","url":"https://www.perforce.com/","name":"Perforce","brand":[{"@type":"Brand","name":"Helix Core","logo":"https://lolma.us/images/linked-data/helix-core-logo-8c5164957fa78647968b2db6e0893567.png","url":"https://www.perforce.com/products/helix-core","description":"Version Control + Swarm Code Review &amp; Collaboration"},{"@type":"Brand","name":"Hansoft","logo":"https://lolma.us/images/linked-data/hansoft-logo-7658d48e82acda65c2106b2eba082e57.png","url":"https://hansoft.com/","description":"Agile Project &amp; Product Management Solution"},{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},{"@type":"Brand","name":"Helix ALM","logo":"https://lolma.us/images/linked-data/helix-alm-logo-9b37cab7b9b913e82c6b38a99f43a4e2.png","url":"https://www.perforce.com/products/helix-alm","description":"Flexible, End-to-End Application Lifecycle Management"}]},"nationality":{"@type":"Country","name":"Russia","alternateName":"Russian Federation"}},"accessMode":"textual","inLanguage":"ru","audience":{"@type":"Audience","audienceType":["developers","web developers","javascript developers","js developers","ember developers","emberjs developers"]},"license":{"@type":"CreativeWork","name":"Creative Commons Attribution 4.0 International","alternateName":"CC BY 4.0","url":"https://creativecommons.org/licenses/by/4.0/","description":"You are free to: Share — copy and redistribute the material in any medium or format; Adapt — remix, transform, and build upon the material for any purpose, even commercially). This license is acceptable for Free Cultural Works. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits."}},{"@type":"Blog","author":{"@type":"Person","name":"Andrey Mikhaylov","givenName":"Andrey","familyName":"Mikhaylov","additionalName":"lolmaus","email":"mailto:lolmaus@gmail.com","image":"https://lolma.us/favicon.jpg","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}},"brand":{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},"homeLocation":{"@type":"Place","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}}},"jobTitle":["Frontend developer","EmberJS developer"],"memberOf":{"@type":"Organization","logo":"https://lolma.us/images/linked-data/perforce-logo.png","url":"https://www.perforce.com/","name":"Perforce","brand":[{"@type":"Brand","name":"Helix Core","logo":"https://lolma.us/images/linked-data/helix-core-logo-8c5164957fa78647968b2db6e0893567.png","url":"https://www.perforce.com/products/helix-core","description":"Version Control + Swarm Code Review &amp; Collaboration"},{"@type":"Brand","name":"Hansoft","logo":"https://lolma.us/images/linked-data/hansoft-logo-7658d48e82acda65c2106b2eba082e57.png","url":"https://hansoft.com/","description":"Agile Project &amp; Product Management Solution"},{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},{"@type":"Brand","name":"Helix ALM","logo":"https://lolma.us/images/linked-data/helix-alm-logo-9b37cab7b9b913e82c6b38a99f43a4e2.png","url":"https://www.perforce.com/products/helix-alm","description":"Flexible, End-to-End Application Lifecycle Management"}]},"nationality":{"@type":"Country","name":"Russia","alternateName":"Russian Federation"}},"accessMode":"textual","inLanguage":"ru","audience":{"@type":"Audience","audienceType":["developers","web developers","javascript developers","js developers","ember developers","emberjs developers"]},"license":{"@type":"CreativeWork","name":"Creative Commons Attribution 4.0 International","alternateName":"CC BY 4.0","url":"https://creativecommons.org/licenses/by/4.0/","description":"You are free to: Share — copy and redistribute the material in any medium or format; Adapt — remix, transform, and build upon the material for any purpose, even commercially). This license is acceptable for Free Cultural Works. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits."},"name":"Блог Андрея Михайлова (lolmaus)","description":"Заметки о вэб-разработке, в основном о JavaScript и EmberJS","url":"https://lolma.us/ru/blog/","keywords":["development","web development","webdev","ember","emberjs","js","javascript","frontend"]},{"@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://lolma.us/ru/blog/","name":"Блог"}},{"@type":"ListItem","position":2,"item":{"@id":"https://lolma.us/ru/blog/promise-proxy-mixin/","name":"PromiseProxyMixin: нативная альтернатива ember-concurrency"}}]},{"@type":"TechArticle","author":{"@type":"Person","name":"Andrey Mikhaylov","givenName":"Andrey","familyName":"Mikhaylov","additionalName":"lolmaus","email":"mailto:lolmaus@gmail.com","image":"https://lolma.us/favicon.jpg","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}},"brand":{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},"homeLocation":{"@type":"Place","address":{"@type":"PostalAddress","addressCountry":"Russia","addressLocality":"Moscow","availableLanguage":{"@type":"Language","name":["Russian"]}}},"jobTitle":["Frontend developer","EmberJS developer"],"memberOf":{"@type":"Organization","logo":"https://lolma.us/images/linked-data/perforce-logo.png","url":"https://www.perforce.com/","name":"Perforce","brand":[{"@type":"Brand","name":"Helix Core","logo":"https://lolma.us/images/linked-data/helix-core-logo-8c5164957fa78647968b2db6e0893567.png","url":"https://www.perforce.com/products/helix-core","description":"Version Control + Swarm Code Review &amp; Collaboration"},{"@type":"Brand","name":"Hansoft","logo":"https://lolma.us/images/linked-data/hansoft-logo-7658d48e82acda65c2106b2eba082e57.png","url":"https://hansoft.com/","description":"Agile Project &amp; Product Management Solution"},{"@type":"Brand","name":"Helix TeamHub","logo":"https://lolma.us/images/linked-data/helix-teamhub-logo-0fe238b12e2dddfd8954425c9c94236a.png","url":"https://www.perforce.com/products/helix-teamhub","description":"Code Hosting and Collaboration for Git+"},{"@type":"Brand","name":"Helix ALM","logo":"https://lolma.us/images/linked-data/helix-alm-logo-9b37cab7b9b913e82c6b38a99f43a4e2.png","url":"https://www.perforce.com/products/helix-alm","description":"Flexible, End-to-End Application Lifecycle Management"}]},"nationality":{"@type":"Country","name":"Russia","alternateName":"Russian Federation"}},"accessMode":"textual","inLanguage":"ru","audience":{"@type":"Audience","audienceType":["developers","web developers","javascript developers","js developers","ember developers","emberjs developers"]},"license":{"@type":"CreativeWork","name":"Creative Commons Attribution 4.0 International","alternateName":"CC BY 4.0","url":"https://creativecommons.org/licenses/by/4.0/","description":"You are free to: Share — copy and redistribute the material in any medium or format; Adapt — remix, transform, and build upon the material for any purpose, even commercially). This license is acceptable for Free Cultural Works. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits."},"headline":"PromiseProxyMixin: нативная альтернатива ember-concurrency","description":"ember-concurrency — исключительно мощный и полезный аддон. Однако если ваш единственный юз-кейс — это обращаться к серверу, то взгляните на легковесную альтернативу","image":"https://lolma.us/favicon.jpg","datePublished":"2018-01-05T00:00:00.000Z","proficiency":"beginner","mainEntityOfPage":{"@type":"WebPage","@id":"https://lolma.us/ru/blog/promise-proxy-mixin/"}}]}</script>
<meta name="ember-cli-head-end">


    <link integrity="" rel="stylesheet" href="/assets/vendor-10c46aeeb15514da80ccb4d3f41b4526.css">
    <link integrity="" rel="stylesheet" href="/assets/lolma-us-7bea756b2ad871bcdb1fb19ad6ecdba3.css">
    <link href="https://fonts.googleapis.com/css?family=PT+Sans+Caption|Merriweather:400,400i,700&amp;subset=cyrillic" rel="stylesheet">

    
  <link rel="yandex-tableau-widget" href="/yandex-browser-manifest.json">
<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="228x228" href="/coast-228x228.png">
<link rel="manifest" href="/manifest.json">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#fff">
<meta name="application-name">
<meta name="msapplication-TileColor" content="#fff">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="msapplication-config" content="/browserconfig.xml">
<link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 1)" href="/apple-touch-startup-image-320x460.png">
<link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-640x920.png">
<link rel="apple-touch-startup-image" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-640x1096.png">
<link rel="apple-touch-startup-image" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-750x1294.png">
<link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 3)" href="/apple-touch-startup-image-1182x2208.png">
<link rel="apple-touch-startup-image" media="(device-width: 414px) and (device-height: 736px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 3)" href="/apple-touch-startup-image-1242x2148.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 1)" href="/apple-touch-startup-image-748x1024.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 1)" href="/apple-touch-startup-image-768x1004.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-1496x2048.png">
<link rel="apple-touch-startup-image" media="(device-width: 768px) and (device-height: 1024px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)" href="/apple-touch-startup-image-1536x2008.png">
</head>
  <body>
    <div id="ember2926" class="ember-view"><!---->

<div class="route-locale">

  <input type="checkbox" id="route-locale-menuToggler" class="route-locale-menuToggler ember-checkbox ember-view">

  <label for="route-locale-menuToggler" class="route-locale-burger">
    <svg height="25" viewBox="0 0 25 25" width="25" xmlns="http://www.w3.org/2000/svg" class="route-locale-burger-icon"><title/><path d="M0 2h25v4H0V2zm0 8h25v4H0v-4zm0 8h25v4H0v-4z" fill="#000" fill-rule="evenodd"/></svg>
  </label>

  <label for="route-locale-menuToggler" class="route-locale-backdrop"></label>



  <div id="ember2930" class="route-locale-menu sideMenu ember-view"><div class="route-locale-menu-greeting">
  Ты сегодня лучше всех!
  <span class="route-locale-menu-greeting-emoji">😎</span>
</div>

<div class="route-locale-menu-items">
<!---->
    <a href="/ru" id="ember2935" class="route-locale-menu-item _resume ember-view">Резюме</a>

  <a href="https://github.com/lolmaus/lolma.us" class="route-locale-menu-item _source -no-icon">
    Исходник на GitHub
    <span class="externalLink"></span>
  </a>

<a href="/en/blog/promise-proxy-mixin" id="ember2944" class="route-locale-menu-item _locale ember-view">    Switch to English
</a></div></div>



  <div class="route-locale-content">
    <div class="route-blog">


<div id="ember2950" class="secTion ember-view"><div class="secTion-inner ">
      <div class="route-blog-sidebar">
      <div class="route-blog-sidebar-section _avatar">
        <img src="/favicon.jpg" alt="Андрей Михайлов" width="512" height="512" class="route-blog-sidebar-avatar">
      </div>

      <div class="route-blog-sidebar-section _content">
        <h2 class="route-blog-title">
          Андрей Михайлов
          @lolmaus
        </h2>

        <div class="route-blog-subtitle">
          фронтенд&#8209;разработчик, EmberJS&#8209;энтузиаст
        </div>

        <div id="ember2963" class="route-blogIndex-menu horizontalMenu ember-view"><div class="horizontalMenu-item _blog">
  <a href="/ru/blog" id="ember2964" class="horizontalMenu-item-link active ember-view">Блог</a>
</div>


<div class="horizontalMenu-item _resume">
  <a href="/ru" id="ember2969" class="horizontalMenu-item-link ember-view">Резюме</a>
</div>


<div class="horizontalMenu-item _source">
  <a href="https://github.com/lolmaus/lolma.us" class="horizontalMenu-item-link -no-icon -has-inner">
    <span class="horizontalMenu-item-link-inner">Исходник на GitHub</span><span class="externalLink"></span>
  </a>
</div>


<div class="horizontalMenu-item _locale">
<a href="/en/blog/promise-proxy-mixin" id="ember2978" class="horizontalMenu-item-link ember-view">    Switch to English
</a></div></div>
      </div>
      
      <div class="route-blog-sidebar-section _bottom">

        <a href="https://creativecommons.org/licenses/by/4.0/" class="route-blog-sidebar-section-bottom-link -no-icon">
          <svg version="1" xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="5.5 -3.5 64 64" class="route-blog-sidebar-section-bottom-icon _cc" alt="Лицензия Creative Commons 4.0 Attribution" title="Лицензия Creative Commons 4.0 Attribution"><circle fill="#FFF" cx="37.637" cy="28.806" r="28.276"/><path d="M37.443-3.5c8.988 0 16.57 3.085 22.742 9.257C66.393 11.967 69.5 19.548 69.5 28.5c0 8.991-3.049 16.476-9.145 22.456-6.476 6.363-14.113 9.544-22.912 9.544-8.649 0-16.153-3.144-22.514-9.43C8.644 44.784 5.5 37.262 5.5 28.5c0-8.761 3.144-16.342 9.429-22.742C21.101-.415 28.604-3.5 37.443-3.5zm.114 5.772c-7.276 0-13.428 2.553-18.457 7.657-5.22 5.334-7.829 11.525-7.829 18.572 0 7.086 2.59 13.22 7.77 18.398 5.181 5.182 11.352 7.771 18.514 7.771 7.123 0 13.334-2.607 18.629-7.828 5.029-4.838 7.543-10.952 7.543-18.343 0-7.276-2.553-13.465-7.656-18.571-5.104-5.104-11.276-7.656-18.514-7.656zm8.572 18.285v13.085h-3.656v15.542h-9.944V33.643h-3.656V20.557c0-.572.2-1.057.599-1.457.401-.399.887-.6 1.457-.6h13.144c.533 0 1.01.2 1.428.6.417.4.628.886.628 1.457zm-13.087-8.228c0-3.008 1.485-4.514 4.458-4.514s4.457 1.504 4.457 4.514c0 2.971-1.486 4.457-4.457 4.457s-4.458-1.486-4.458-4.457z"/></svg>
        </a>

        <a href="https://lolma.us/rss_ru.xml" class="route-blog-sidebar-section-bottom-link -no-icon">
          <svg xmlns="http://www.w3.org/2000/svg" height="49.25" viewBox="0 0 49.249999 49.249999" width="49.25" class="route-blog-sidebar-section-bottom-icon _rss" alt="RSS" title="RSS"><path d="M24.625 0C11.025 0 0 11.025 0 24.625 0 38.227 11.024 49.25 24.625 49.25c13.602 0 24.625-11.023 24.625-24.625C49.25 11.025 38.226 0 24.625 0zm-7.637 35.735a3.238 3.238 0 1 1 .002-6.476 3.238 3.238 0 0 1-.002 6.476zm8.123.021c0-3.057-1.182-5.928-3.33-8.082a11.247 11.247 0 0 0-8.028-3.342v-4.674c8.84 0 16.03 7.223 16.03 16.098h-4.672zm8.256.004c0-10.867-8.795-19.711-19.606-19.711v-4.676c13.387 0 24.28 10.942 24.28 24.387h-4.674z"/></svg>
        </a>
      </div>
      
    </div>

</div></div>

<div id="ember2991" class="route-blog-content secTion ember-view"><div class="secTion-inner route-blog-content-inner">
      <div class="route-blogPost">

  <a href="/ru/blog" id="ember2993" class="route-blogPost-back active ember-view">← В блог</a>

  <div id="ember2998" class="route-blogPost-post blogPost -full ember-view">  <h1 id="ember2999" class="blogPost-title ember-view"><p>PromiseProxyMixin: нативная альтернатива ember-concurrency</p>
</h1>



<p class="blogPost-date">
  5-го января 2018

<!---->
</p>



  <div id="ember3000" class="blogPost-summary ember-view"><p>ember-concurrency — исключительно мощный и полезный аддон. Однако если ваш единственный юз-кейс — это обращаться к серверу, то взгляните на легковесную альтернативу</p>
</div>



  <div id="ember3001" class="blogPost-body ember-view"><div class="exclamation"></div>
<blockquote>
  <p>Это перевод моей статьи, которую я изначально опубликовал в блоге компании Deveo. Когда она была поглощена компанией Perforce, ее блог был закрыт.</p>
</blockquote>
<p><a href="http://ember-concurrency.com">ember-concurrency</a> — это исключительно мощный и удобный аддон, решающий множество разнообразных задач.</p>
<p>Однако самая типовая задача — просто обращаться к серверу: либо загружать данные, либо передавать. Вы можете посчитать чрезмерным устанавливать <code>ember-concurrency</code> только ради этого.</p>
<p>И будете совершенно правы. В Ember имеются все необходимые примитивы для решения этой задачи в том же стиле, что <code>ember-concurrency</code>: просто, эффективно и в рамках Ember way.</p>
<h2 id="пример-задачи" class="headingWithLink"><a href="#пример-задачи" class="headingWithLink-link">#</a>Пример задачи</h2>
<p>Позвольте продемонстрировать предлагаемый мной подход на простом примере. Мы будем получать с GitHub количество доступных обращений к GitHub API:</p>
<div class="code-block"><pre><code class="hljs">GET http://api.github.com/rate_limit</code></pre></div>
<p>Я выбрал именно этот API endpoint, потому что это единственный endpoint, который GitHub не ограничивает по количеству обращений. :trollface:</p>
<p>Давайте для начала реализуем метод загрузки данных:</p>
<div class="code-block"><pre><code class="js language-js hljs"><span class="hljs-keyword">import</span> Controller <span class="hljs-keyword">from</span> <span class="hljs-string">'@ember/controller'</span>
<span class="hljs-keyword">import</span> fetch <span class="hljs-keyword">from</span> <span class="hljs-string">'fetch'</span>

Controller.extend({
  _fetchGitHubRate () {
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'https://api.github.com/rate_limit'</span>)
      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());
  },
});</code></pre></div>
<p>Я использую аддон <a href="https://github.com/ember-cli/ember-fetch">ember-fetch</a> ради его простоты, но на его месте может быть всё что угодно, что возвращает promise, например, сервис <a href="https://github.com/ember-cli/ember-ajax">ember-ajax</a>.</p>
<p>Метод может находиться не только в контроллере, но и в любой другой сущности Ember: компоненте, сервисе, модели и т. д.</p>
<h2 id="встречайте-promiseproxymixin" class="headingWithLink"><a href="#встречайте-promiseproxymixin" class="headingWithLink-link">#</a>Встречайте <code>PromiseProxyMixin</code></h2>
<p>Вы наверняка слышали мнение, что возвращать promise из computed property (CP) — плохая идея. С <a href="https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin">PromiseProxyMixin</a> это не так.</p>
<p>Давайте создадим класс, в который включим <code>PromiseProxyMixin</code>. Это можно сделать на верхнем уровне вашего модуля:</p>
<div class="code-block"><pre><code class="js language-js hljs"><span class="hljs-keyword">import</span> EmberObject <span class="hljs-keyword">from</span> <span class="hljs-string">'@ember/object'</span>
<span class="hljs-keyword">import</span> PromiseProxyMixin <span class="hljs-keyword">from</span> <span class="hljs-string">'@ember/object/promise-proxy-mixin'</span>

<span class="hljs-keyword">const</span> PromiseObject = EmberObject.extend(PromiseProxyMixin);</code></pre></div>
<p>Теперь мы можем обернуть promise в <code>PromiseObject</code>. Обязательно разделите promise и proxy на два отдельных свойства:</p>
<div class="code-block"><pre><code class="js language-js hljs"><span class="hljs-comment">// This CP returns a simple promise</span>
gitHubRatePromise: computed(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._fetchGitHubRate();
}),

<span class="hljs-comment">// This CP wraps the promise with with `PromiseObject` </span>
gitHubRateProxy: computed(<span class="hljs-string">'gitHubRatePromise'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'gitHubRatePromise'</span>);
  <span class="hljs-keyword">return</span> promise &amp;&amp; PromiseObject.create({promise});
}),</code></pre></div>
<p>Обратите внимание на <code>promise &amp;&amp;</code>. Если promise отсутствует, proxy создаваться не должен, т. к. в этом случае он "упадет" с ошибкой.</p>
<h2 id="обращение-к-содержимому-promiseа" class="headingWithLink"><a href="#обращение-к-содержимому-promiseа" class="headingWithLink-link">#</a>Обращение к содержимому promise'а</h2>
<p>API endpoint, к которому мы обращаемся, возвращает данные в таком формате (фрагмент):</p>
<div class="code-block"><pre><code class="js language-js hljs">{
  <span class="hljs-string">"resources"</span>: {
    <span class="hljs-string">"core"</span>: {
      <span class="hljs-string">"limit"</span>: <span class="hljs-number">60</span>,
      <span class="hljs-string">"remaining"</span>: <span class="hljs-number">60</span>,
      <span class="hljs-string">"reset"</span>: <span class="hljs-number">1486831110</span>
    },
}</code></pre></div>
<p>Этот хэш будет доступен в шаблоне как <code>gitHubRateProxy.content</code>. Вы можете работать с этим свойством как обычно:</p>
<div class="code-block"><pre><code class="js language-js hljs">  gitHubRate:          reads(<span class="hljs-string">'gitHubRateProxy.content'</span>),
  <span class="hljs-attr">gitHubRateRemaining</span>: reads(<span class="hljs-string">'gitHubRate.resources.core.remaining'</span>),
  <span class="hljs-attr">gitHubRateLimit</span>:     reads(<span class="hljs-string">'gitHubRate.resources.core.limit'</span>),</code></pre></div>
<p>Пока promise не resolved, эти свойства будут иметь значение <code>undefined</code>. Когда мы будем использовать их в другом computed property, надо защититься от <code>undefined</code>:</p>
<div class="code-block"><pre><code class="js language-js hljs">  gitHubRatePercentage: computed(<span class="hljs-string">'gitHubRateRemaining'</span>, <span class="hljs-string">'gitHubRateLimit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> gitHubRateRemaining = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'gitHubRateRemaining'</span>);
    <span class="hljs-keyword">const</span> gitHubRateLimit     = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'gitHubRateLimit'</span>);

    <span class="hljs-comment">// We don't want a `NaN`!</span>
    <span class="hljs-keyword">if</span> (gitHubRateRemaining == <span class="hljs-literal">null</span> || gitHubRateLimit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> percentage  = <span class="hljs-built_in">Math</span>.round(gitHubRateRemaining / gitHubRateLimit * <span class="hljs-number">100</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${percentage}</span>%`</span>;
  }),</code></pre></div>
<p>Применим результат в шаблоне:</p>
<div class="code-block"><pre><code class="handlebars language-handlebars hljs"><span class="xml">Your GitHub rate limit: </span><span class="hljs-template-variable">{{gitHubRateRemaining}}</span><span class="xml"> (</span><span class="hljs-template-variable">{{gitHubRatePercentage}}</span><span class="xml">)</span></code></pre></div>
<h2 id="как-это-работает" class="headingWithLink"><a href="#как-это-работает" class="headingWithLink-link">#</a>Как это работает</h2>
<p>Изначально, CP <code>gitHubRatePromise</code> не рассчитано, и обращение к серверу не происходит.</p>
<p>Когда рендерится наш шаблон, происходит считывание свойства <code>gitHubRateRemaining</code>. Это CP зависит от <code>gitHubRateProxy</code>. Тот, в свою очередь, обращается к <code>gitHubRatePromise</code>.</p>
<p>При первом обращении к <code>gitHubRatePromise</code> выполняется метод <code>_fetchGitHubRate</code> и совершается запрос. Метод возвращает promise, который кэшируется в свойстве <code>gitHubRatePromise</code>.</p>
<p>Это означает, что при повторном обращении к свойству будет возвращаться один и тот же promise, и запрос не будет выполняться повторно. По сути, реализуется паттерн <code>drop</code> из <code>ember-concurrency</code>.</p>
<p>Свойство <code>gitHubRateProxy</code> оборачивае promise в proxy <code>PromiseObject</code>. Когда promise отресолвится, его resolve value станет доступно как <code>gitHubRateProxy.content</code>.</p>
<p>Обратите внимание, что данный подход декларативен. Вам не требуется делать этого:</p>
<div class="code-block"><pre><code class="js language-js hljs">didInsertElement () {
  <span class="hljs-keyword">this</span>._super()
  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'fetchGitHubRateTask'</span>).perform()
}</code></pre></div>
<h2 id="учитываем-что-выполнение-promise-занимает-время" class="headingWithLink"><a href="#учитываем-что-выполнение-promise-занимает-время" class="headingWithLink-link">#</a>Учитываем, что выполнение promise занимает время</h2>
<p>Пока promise не отресолвится, содержимое <code>gitHubRateProxy.content</code> будет <code>undefined</code>. Это означает, что пока запрос выполняется, в шаблоне будет пустота. Давайте это исправим.</p>
<p><code>PromiseProxyMixin</code> предоставляет свойство <code>gitHubRateProxy.isPending</code>. Воспользуемся им в шаблоне:</p>
<div class="code-block"><pre><code class="handlebars language-handlebars hljs"><span class="xml"></span><span class="hljs-template-tag">{{#<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> gitHubRateProxy.isPending}}</span><span class="xml">

  Retrieving GitHub rate limit...

</span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">else</span>}}</span><span class="xml">

  Your GitHub rate limit: </span><span class="hljs-template-variable">{{gitHubRateRemaining}}</span><span class="xml"> (</span><span class="hljs-template-variable">{{gitHubRatePercentage}}</span><span class="xml">)

</span><span class="hljs-template-tag">{{/<span class="hljs-name"><span class="hljs-builtin-name">if</span></span>}}</span><span class="xml"></span></code></pre></div>
<p>Вполне естественная запись. Выходит, возвращать promise из computed property не так уж плохо! 😉</p>
<h2 id="учитываем-что-запрос-может-завершиться-неудачей" class="headingWithLink"><a href="#учитываем-что-запрос-может-завершиться-неудачей" class="headingWithLink-link">#</a>Учитываем, что запрос может завершиться неудачей</h2>
<p>Внимательный четатель мог заметить проблему: если promise будет rejected, например, вследствие сетевого сбоя, то reject'нутое состояние promise'а будет закэшировано навсегда. В этом проявляется одно из преимуществ <code>ember-concurrency</code>: он позволяет без труда перезапустить задачу.</p>
<p>В случае с promise нам понадобиться написать несколько строк кода. Идея в том, чтобы перезаписать computed property <code>gitHubRatePromise</code> обычным, не computed, promise'ом:</p>
<div class="code-block"><pre><code class="js language-js hljs">  actions: {
    refetchGitHubRate () {
      <span class="hljs-keyword">this</span>.set(<span class="hljs-string">'gitHubRatePromise'</span>, <span class="hljs-keyword">this</span>._fetchGitHubRate());
    }
  },</code></pre></div>
<p>Вызов этого action'а спровоцирует новый сетевой запрос. Соответствующий promise будет присвоен в свойство <code>gitHubRatePromise</code>, что вызовет пересчет всех свойств, которые от него зависят, и далее по цепочке.</p>
<p>Если promise будет rejected, то свойство <code>gitHubRateProxy.isRejected</code> примет значение <code>true</code>, а rejection value (обычно это объект Error) будет доступно в <code>gitHubRateProxy.reason</code>.</p>
<p>Давайте попробуем:</p>
<div class="code-block"><pre><code class="handlebars language-handlebars hljs"><span class="xml"></span><span class="hljs-template-tag">{{#<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> gitHubRateProxy.isRejected}}</span><span class="xml">

  Failed to retrieve GitHub rate limit.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>

  Reason: </span><span class="hljs-template-variable">{{gitHubRateProxy.reason}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> </span></span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">action</span> 'refetchGitHubRate'}}</span><span class="xml"><span class="hljs-tag">&gt;</span>
    Retry
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

</span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">else</span> <span class="hljs-builtin-name">if</span> gitHubRateProxy.isPending}}</span><span class="xml">

  Retrieving GitHub rate limit...

</span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">else</span>}}</span><span class="xml">

  Your GitHub rate limit: </span><span class="hljs-template-variable">{{gitHubRateRemaining}}</span><span class="xml"> (</span><span class="hljs-template-variable">{{gitHubRatePercentage}}</span><span class="xml">)

</span><span class="hljs-template-tag">{{/<span class="hljs-name"><span class="hljs-builtin-name">if</span></span>}}</span><span class="xml"></span></code></pre></div>
<h2 id="демо" class="headingWithLink"><a href="#демо" class="headingWithLink-link">#</a>Демо</h2>
<p>Посмотреть полный код примера и попробовать его в деле вы можете <a href="https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs">на Ember Twiddle</a>:</p>
<iframe src="https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?fullScreen=true" style="width: 100%; height: 500px; border: 2px solid biege;"></iframe>
<p><br></p>
<p><a href="https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs">Тут</a> вы найдете аналогичный пример на <code>ember-concurrency</code> для сравнения.</p>
<h2 id="переносим-логику-в-севрис-для-переиспользования" class="headingWithLink"><a href="#переносим-логику-в-севрис-для-переиспользования" class="headingWithLink-link">#</a>Переносим логику в севрис для переиспользования</h2>
<p>Если вы поместили описанную логику в компонент, который используется в двух разных маршрутах, то при переходе между маршрутами данные будут запрашиваться повторно, поскольку при покидании маршрута компонент уничтожается, а вместе с ним и promise.</p>
<p>Вероятно, предпочтительнее будет не перезапрашивать данные при смене маршрута, а делать это только по запросу. Для этого promise должен кэшироваться глобально и не быть привязан к компоненту.</p>
<p>Очевидное решение — поместить эту логику в сервис. Очень удобно для этого расширять сервис <a href="https://github.com/ember-cli/ember-ajax">ember-ajax</a>.</p>
<h2 id="emberobjectproxy-не-нужен" class="headingWithLink"><a href="#emberobjectproxy-не-нужен" class="headingWithLink-link">#</a><code>Ember.ObjectProxy</code> не нужен</h2>
<p><a href="https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin">Официальная документация по PromiseProxyMixin</a> предлагает использовать<code>Ember.ObjectProxy</code> в качестве базвого класса для примешивания <code>PromiseProxyMixin</code>. Однако <code>ObjectProxy</code> применяет кое-какую черную магию, из-за чего я предпочитаю его избегать.</p>
<p>Единственное преимущество <code>ObjectProxy</code> — это сократить этот путь:</p>
<div class="code-block"><pre><code class="hljs">gitHubRateProxy.content.resources.core.remaining</code></pre></div>
<p>до этого:</p>
<div class="code-block"><pre><code class="hljs">gitHubRateProxy.resources.core.remaining</code></pre></div>
<p>Всего лишь пропадает необходимость писать <code>.content</code>. Не такая уж большая польза.</p>
<p>Естественно, эта черная магия не работает с массивами. Для массивов предлагается использовать <code>Ember.ArrayProxy</code>, который в свою очередь не работает с объектами. А если ваш promise возвращает инстанс класса, а не просто хэш, то не подходит ни один из вариантов.</p>
<p><code>Ember.Object</code>, напротив, универсален. Необходимость дописывать <code>.content</code> — это малая цена за прозрачность происходящего. Я думаю, <code>ObjectProxy</code> and <code>ArrayProxy</code> — это пережитки времен давно ушедших  <code>ObjectController</code> и <code>ArrayController</code>.</p>
<h2 id="ember-deferred-content-и-ember-async-button-тоже-не-нужны" class="headingWithLink"><a href="#ember-deferred-content-и-ember-async-button-тоже-не-нужны" class="headingWithLink-link">#</a><code>ember-deferred-content</code> и <code>ember-async-button</code> тоже не нужны</h2>
<p>Эти два аддона оборачивают promise в proxy на уровне шаблона. Они предлагают своеобразные шаблонные конструкции, не имея никаких преимуществ над <code>PromiseProxyMixin</code>.</p>
<p>Сравните:</p>
<div class="code-block"><pre><code class="handlebars language-handlebars hljs"><span class="xml"></span><span class="hljs-template-tag">{{#<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> gitHubRateProxy.isRejected}}</span><span class="xml">

  Failed to retrieve GitHub rate limit.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>

  Reason: </span><span class="hljs-template-variable">{{gitHubRateProxy.reason}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> </span></span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">action</span> 'refetchGitHubRate'}}</span><span class="xml"><span class="hljs-tag">&gt;</span>
    Retry
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

</span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">else</span> <span class="hljs-builtin-name">if</span> gitHubRateProxy.isPending}}</span><span class="xml">

  Retrieving GitHub rate limit...

</span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">else</span>}}</span><span class="xml">

  Your GitHub rate limit: </span><span class="hljs-template-variable">{{gitHubRateRemaining}}</span><span class="xml"> (</span><span class="hljs-template-variable">{{gitHubRatePercentage}}</span><span class="xml">)

</span><span class="hljs-template-tag">{{/<span class="hljs-name"><span class="hljs-builtin-name">if</span></span>}}</span><span class="xml"></span></code></pre></div>
<div class="code-block"><pre><code class="handlebars language-handlebars hljs"><span class="xml"></span><span class="hljs-template-tag">{{#<span class="hljs-name">deferred-content</span> gitHubRatePromise as |d|}}</span><span class="xml">
  </span><span class="hljs-template-tag">{{#<span class="hljs-name">d.pending</span>}}</span><span class="xml">
    Retrieving GitHub rate limit...
  </span><span class="hljs-template-tag">{{/<span class="hljs-name">d.pending</span>}}</span><span class="xml">

  </span><span class="hljs-template-tag">{{#<span class="hljs-name">d.fulfilled</span> as |gitHubRate|}}</span><span class="xml">
    Your GitHub rate limit:

    </span><span class="hljs-template-variable">{{gitHubRate.resources.core.remaining}}</span><span class="xml">

    (</span><span class="hljs-template-variable">{{multiply
      (divide gitHubRate.resources.core.remaining gitHubRate.resources.core.limit)
      100
    }}</span><span class="xml">%)
  </span><span class="hljs-template-tag">{{/<span class="hljs-name">d.fulfilled</span>}}</span><span class="xml">

  </span><span class="hljs-template-tag">{{#<span class="hljs-name">d.rejected</span> as |reason|}}</span><span class="xml">
    Failed to retrieve GitHub rate limit.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>

    Reason: </span><span class="hljs-template-variable">{{reason}}</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> </span></span><span class="hljs-template-variable">{{<span class="hljs-builtin-name">action</span> 'refetchGitHubRate'}}</span><span class="xml"><span class="hljs-tag">&gt;</span>
      Retry
    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  </span><span class="hljs-template-tag">{{/<span class="hljs-name">d.rejected</span>}}</span><span class="xml">
</span><span class="hljs-template-tag">{{/<span class="hljs-name">deferred-content</span>}}</span><span class="xml"></span></code></pre></div>
<p>Обратите внимание, что <code>ember-deferred-content</code> вынуждает вас вычислять проценты на уровне шаблона.</p>
<h2 id="я-не-отговариваю-вас-использовать-ember-concurrency" class="headingWithLink"><a href="#я-не-отговариваю-вас-использовать-ember-concurrency" class="headingWithLink-link">#</a>Я не отговариваю вас использовать <code>ember-concurrency</code></h2>
<p>Основная цель этой статьи — показать вам данный прием и заставить немного задуматься. Этот прием весьма практичен, и я часто пользуюсь им в своих проектах, где не используется <code>ember-concurrency</code>.</p>
<p>Отказаться от <code>ember-concurrency</code> в пользу <code>PromiseProxyMixin</code> можно по двум причинам:</p>
<ul>
<li>вы считаете каждый килобайт размера вашего дистрибутива;</li>
<li>вы хотите обойтись без лишних сущностей, слоев и абстракций.</li>
</ul>
<p>Если же вы уже хорошо знакомы с <code>ember-concurrency</code>, и он включен в ваш проект, то использовать <code>PromiseProxyMixin</code> нет смысла. Скорее всего, код на <code>ember-concurrency</code> получится немного короче:</p>
<div class="code-block"><pre><code class="js language-js hljs">gitHubRateTask: task(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>._fetchGitHubRate();
}).restartable().on(<span class="hljs-string">'didInsertElement'</span>)

gitHubRate:          reads(<span class="hljs-string">'gitHubRateTask.last.value'</span>),
<span class="hljs-attr">gitHubRateRemaining</span>: reads(<span class="hljs-string">'gitHubRate.resources.core.remaining'</span>),
<span class="hljs-attr">gitHubRateLimit</span>:     reads(<span class="hljs-string">'gitHubRate.resources.core.limit'</span>),

<span class="hljs-comment">// Если этого не сделать, запрос не будет выполнен. Императивненько. :(</span>
didInsertElement () {
  <span class="hljs-keyword">this</span>._super()
  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'fetchGitHubRateTask'</span>).perform()
}</code></pre></div>
<p>Повторяю <a href="https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2&openFiles=controllers.application.js%2Ctemplates.application.hbs">ссылку</a> на пример, выполненный на <code>ember-concurrency</code>.</p>
<h2 id="обращение-к-предыдущему-ответу-сервера-после-того-как-повторный-запрос-завершился-неудачей" class="headingWithLink"><a href="#обращение-к-предыдущему-ответу-сервера-после-того-как-повторный-запрос-завершился-неудачей" class="headingWithLink-link">#</a>Обращение к предыдущему ответу сервера, после того как повторный запрос завершился неудачей</h2>
<p>Представьте такую ситуацию. Мы опрашиваем сервер каждую секунду, чтобы показывать актуальные данные. Мы хотим, чтобы в случае сетевого сбоя на экране продолжали отображаться последние успешно запрошенные данные.</p>
<p><code>ember-concurrency</code> предоставляет доступ к последним значениям resolution и rejection, если они имеются. Они остаются доступны, даже если задача перезапущена:</p>
<div class="code-block"><pre><code class="handlebars language-handlebars hljs"><span class="xml"></span><span class="hljs-template-variable">{{gitHubRateTask.lastSuccessful.value}}</span><span class="xml"></span></code></pre></div>
<p>Если мы поступим так же с <code>PromiseProxyMixin</code>, то значение на странице будет моргать каждую секунду. Ведь при каждом повторном запросе promise перезаписывается, и предыдущее resolution value становится недоступным.</p>
<p>Проще всего решить проблему, добавив <code>.then(result =&gt; this.set('result', result))</code> к promise, чтобы resolution value извлекался из promise и хранился отдельно.</p>
<p>Это нормальное решение, но оно мне не нравится своей императивностью. Вместо этого, взгляните на такой CP макрос:</p>
<div class="code-block"><pre><code class="js language-js hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachingMacro</span> (<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">let</span> cache

  <span class="hljs-keyword">return</span> computed(key, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">this</span>.get(key)

    <span class="hljs-keyword">return</span> value == <span class="hljs-literal">null</span>
      ? cache
      : cache = value
  })
}</code></pre></div>
<p>Его можно использовать так:</p>
<div class="code-block"><pre><code class="js language-js hljs">gitHubRate:          cachingMacro(<span class="hljs-string">'gitHubRateProxy.content'</span>),
<span class="hljs-attr">gitHubRateRemaining</span>: reads(<span class="hljs-string">'gitHubRate.resources.core.remaining'</span>),
<span class="hljs-attr">gitHubRateLimit</span>:     reads(<span class="hljs-string">'gitHubRate.resources.core.limit'</span>),</code></pre></div>
<p>В результате, когда promise перезаписывается вторым promise'ом, который завершается неудачей, свойство <code>gitHubRate</code> будет по-прежнему хранить resolution value первого promise'а.</p>
<p>Ну или вы можете применить <code>ember-concurrency</code> в конце концов. 😬</p>
<h2 id="что-скажете" class="headingWithLink"><a href="#что-скажете" class="headingWithLink-link">#</a>Что скажете?</h2>
<p>Обязательно поделитесь вашими соображениями, возражениями и идеями в комментариях внизу. Самая ценная часть любой статьи — это всегда обсуждение, которое за ней следует!</p>
</div>
</div>

<!---->
</div>

  
</div></div>


</div>

  </div>

</div></div><script type="fastboot/shoebox" id="shoebox-ember-data-store">{"types":{"cache-buster":[{"data":{"id":"buster","attributes":{"string":"61e6c79273e8a6d750b38a3ccf881b7a52a816cf9410a1af441823157101e378"},"type":"cache-busters"}}],"experience":[],"markdown-block":[],"post":[{"data":{"id":"promise-proxy-mixin-ru","attributes":{"title":"PromiseProxyMixin: нативная альтернатива ember-concurrency","body":"\n\u003cdiv class=\"exclamation\"\u003e\u003c/div\u003e\n\n\u003e Это перевод моей статьи, которую я изначально опубликовал в блоге компании Deveo. Когда она была поглощена компанией Perforce, ее блог был закрыт.\n\n\n\n\n[ember-concurrency](http://ember-concurrency.com) — это исключительно мощный и удобный аддон, решающий множество разнообразных задач.\n\nОднако самая типовая задача — просто обращаться к серверу: либо загружать данные, либо передавать. Вы можете посчитать чрезмерным устанавливать `ember-concurrency` только ради этого.\n\nИ будете совершенно правы. В Ember имеются все необходимые примитивы для решения этой задачи в том же стиле, что `ember-concurrency`: просто, эффективно и в рамках Ember way.\n\n\n\n## Пример задачи\n\nПозвольте продемонстрировать предлагаемый мной подход на простом примере. Мы будем получать с GitHub количество доступных обращений к GitHub API:\n\n    GET http://api.github.com/rate_limit\n\nЯ выбрал именно этот API endpoint, потому что это единственный endpoint, который GitHub не ограничивает по количеству обращений. :trollface:\n\nДавайте для начала реализуем метод загрузки данных:\n\n```js\nimport Controller from '@ember/controller'\nimport fetch from 'fetch'\n\nController.extend({\n  _fetchGitHubRate () {\n    return fetch('https://api.github.com/rate_limit')\n      .then(response =\u003e response.json());\n  },\n});\n```\n\nЯ использую аддон [ember-fetch](https://github.com/ember-cli/ember-fetch) ради его простоты, но на его месте может быть всё что угодно, что возвращает promise, например, сервис [ember-ajax](https://github.com/ember-cli/ember-ajax).\n\nМетод может находиться не только в контроллере, но и в любой другой сущности Ember: компоненте, сервисе, модели и т. д.\n\n\n\n## Встречайте `PromiseProxyMixin`\n\nВы наверняка слышали мнение, что возвращать promise из computed property (CP) — плохая идея. С [PromiseProxyMixin](https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin) это не так.\n\nДавайте создадим класс, в который включим `PromiseProxyMixin`. Это можно сделать на верхнем уровне вашего модуля:\n\n```js\nimport EmberObject from '@ember/object'\nimport PromiseProxyMixin from '@ember/object/promise-proxy-mixin'\n\nconst PromiseObject = EmberObject.extend(PromiseProxyMixin);\n```\n\nТеперь мы можем обернуть promise в `PromiseObject`. Обязательно разделите promise и proxy на два отдельных свойства:\n\n```js\n// This CP returns a simple promise\ngitHubRatePromise: computed(function () {\n  return this._fetchGitHubRate();\n}),\n\n// This CP wraps the promise with with `PromiseObject` \ngitHubRateProxy: computed('gitHubRatePromise', function () {\n  const promise = this.get('gitHubRatePromise');\n  return promise \u0026\u0026 PromiseObject.create({promise});\n}),\n```\n\nОбратите внимание на `promise \u0026\u0026`. Если promise отсутствует, proxy создаваться не должен, т. к. в этом случае он \"упадет\" с ошибкой.\n\n\n\n## Обращение к содержимому promise'а\n\nAPI endpoint, к которому мы обращаемся, возвращает данные в таком формате (фрагмент):\n\n```js\n{\n  \"resources\": {\n    \"core\": {\n      \"limit\": 60,\n      \"remaining\": 60,\n      \"reset\": 1486831110\n    },\n}\n```\n\nЭтот хэш будет доступен в шаблоне как `gitHubRateProxy.content`. Вы можете работать с этим свойством как обычно:\n\n```js\n  gitHubRate:          reads('gitHubRateProxy.content'),\n  gitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\n  gitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n```\n\nПока promise не resolved, эти свойства будут иметь значение `undefined`. Когда мы будем использовать их в другом computed property, надо защититься от `undefined`:\n\n```js\n  gitHubRatePercentage: computed('gitHubRateRemaining', 'gitHubRateLimit', function () {\n    const gitHubRateRemaining = this.get('gitHubRateRemaining');\n    const gitHubRateLimit     = this.get('gitHubRateLimit');\n    \n    // We don't want a `NaN`!\n    if (gitHubRateRemaining == null || gitHubRateLimit == null) return;\n    \n    const percentage  = Math.round(gitHubRateRemaining / gitHubRateLimit * 100);\n    \n    return `${percentage}%`;\n  }),\n```\n\nПрименим результат в шаблоне:\n\n```handlebars\nYour GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n```\n\n\n\n## Как это работает\n\nИзначально, CP `gitHubRatePromise` не рассчитано, и обращение к серверу не происходит.\n\nКогда рендерится наш шаблон, происходит считывание свойства `gitHubRateRemaining`. Это CP зависит от `gitHubRateProxy`. Тот, в свою очередь, обращается к `gitHubRatePromise`.\n\nПри первом обращении к `gitHubRatePromise` выполняется метод `_fetchGitHubRate` и совершается запрос. Метод возвращает promise, который кэшируется в свойстве `gitHubRatePromise`.\n\nЭто означает, что при повторном обращении к свойству будет возвращаться один и тот же promise, и запрос не будет выполняться повторно. По сути, реализуется паттерн `drop` из `ember-concurrency`.\n\nСвойство `gitHubRateProxy` оборачивае promise в proxy `PromiseObject`. Когда promise отресолвится, его resolve value станет доступно как `gitHubRateProxy.content`.\n\nОбратите внимание, что данный подход декларативен. Вам не требуется делать этого:\n\n```js\ndidInsertElement () {\n  this._super()\n  this.get('fetchGitHubRateTask').perform()\n}\n```\n\n\n\n## Учитываем, что выполнение promise занимает время\n\nПока promise не отресолвится, содержимое `gitHubRateProxy.content` будет `undefined`. Это означает, что пока запрос выполняется, в шаблоне будет пустота. Давайте это исправим.\n\n`PromiseProxyMixin` предоставляет свойство `gitHubRateProxy.isPending`. Воспользуемся им в шаблоне:\n\n```handlebars\n{{#if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\nВполне естественная запись. Выходит, возвращать promise из computed property не так уж плохо! :wink:\n\n\n\n## Учитываем, что запрос может завершиться неудачей\n\nВнимательный четатель мог заметить проблему: если promise будет rejected, например, вследствие сетевого сбоя, то reject'нутое состояние promise'а будет закэшировано навсегда. В этом проявляется одно из преимуществ `ember-concurrency`: он позволяет без труда перезапустить задачу.\n\nВ случае с promise нам понадобиться написать несколько строк кода. Идея в том, чтобы перезаписать computed property `gitHubRatePromise` обычным, не computed, promise'ом:\n\n```js\n  actions: {\n    refetchGitHubRate () {\n      this.set('gitHubRatePromise', this._fetchGitHubRate());\n    }\n  },\n```\n\nВызов этого action'а спровоцирует новый сетевой запрос. Соответствующий promise будет присвоен в свойство `gitHubRatePromise`, что вызовет пересчет всех свойств, которые от него зависят, и далее по цепочке.\n\nЕсли promise будет rejected, то свойство `gitHubRateProxy.isRejected` примет значение `true`, а rejection value (обычно это объект Error) будет доступно в `gitHubRateProxy.reason`.\n\nДавайте попробуем:\n\n```handlebars\n{{#if gitHubRateProxy.isRejected}}\n\n  Failed to retrieve GitHub rate limit.\u003cbr\u003e\n    \n  Reason: {{gitHubRateProxy.reason}}\u003cbr\u003e\n    \n  \u003ca href {{action 'refetchGitHubRate'}}\u003e\n    Retry\n  \u003c/a\u003e\n    \n{{else if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\n\n## Демо\n\nПосмотреть полный код примера и попробовать его в деле вы можете [на Ember Twiddle](https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?numColumns=2\u0026openFiles=controllers.application.js%2Ctemplates.application.hbs):\n\n\u003ciframe src=\"https://ember-twiddle.com/f645d337712394d2ebdf0a7ddd061897?fullScreen=true\" style=\"width: 100%; height: 500px; border: 2px solid biege;\"\u003e\u003c/iframe\u003e\u003cbr\u003e\n\n[Тут](https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2\u0026openFiles=controllers.application.js%2Ctemplates.application.hbs) вы найдете аналогичный пример на `ember-concurrency` для сравнения.\n\n\n\n## Переносим логику в севрис для переиспользования\n\nЕсли вы поместили описанную логику в компонент, который используется в двух разных маршрутах, то при переходе между маршрутами данные будут запрашиваться повторно, поскольку при покидании маршрута компонент уничтожается, а вместе с ним и promise.\n\nВероятно, предпочтительнее будет не перезапрашивать данные при смене маршрута, а делать это только по запросу. Для этого promise должен кэшироваться глобально и не быть привязан к компоненту.\n\nОчевидное решение — поместить эту логику в сервис. Очень удобно для этого расширять сервис [ember-ajax](https://github.com/ember-cli/ember-ajax).\n\n\n\n## `Ember.ObjectProxy` не нужен\n\n[Официальная документация по PromiseProxyMixin](https://emberjs.com/api/ember/2.18/classes/PromiseProxyMixin) предлагает использовать`Ember.ObjectProxy` в качестве базвого класса для примешивания `PromiseProxyMixin`. Однако `ObjectProxy` применяет кое-какую черную магию, из-за чего я предпочитаю его избегать.\n\nЕдинственное преимущество `ObjectProxy` — это сократить этот путь:\n\n    gitHubRateProxy.content.resources.core.remaining\n\nдо этого:\n\n    gitHubRateProxy.resources.core.remaining\n\nВсего лишь пропадает необходимость писать `.content`. Не такая уж большая польза.\n\nЕстественно, эта черная магия не работает с массивами. Для массивов предлагается использовать `Ember.ArrayProxy`, который в свою очередь не работает с объектами. А если ваш promise возвращает инстанс класса, а не просто хэш, то не подходит ни один из вариантов.\n\n`Ember.Object`, напротив, универсален. Необходимость дописывать `.content` — это малая цена за прозрачность происходящего. Я думаю, `ObjectProxy` and `ArrayProxy` — это пережитки времен давно ушедших  `ObjectController` и `ArrayController`.\n\n\n\n## `ember-deferred-content` и `ember-async-button` тоже не нужны\n\nЭти два аддона оборачивают promise в proxy на уровне шаблона. Они предлагают своеобразные шаблонные конструкции, не имея никаких преимуществ над `PromiseProxyMixin`.\n\nСравните:\n\n```handlebars\n{{#if gitHubRateProxy.isRejected}}\n\n  Failed to retrieve GitHub rate limit.\u003cbr\u003e\n    \n  Reason: {{gitHubRateProxy.reason}}\u003cbr\u003e\n    \n  \u003ca href {{action 'refetchGitHubRate'}}\u003e\n    Retry\n  \u003c/a\u003e\n    \n{{else if gitHubRateProxy.isPending}}\n\n  Retrieving GitHub rate limit...\n\n{{else}}\n\n  Your GitHub rate limit: {{gitHubRateRemaining}} ({{gitHubRatePercentage}})\n  \n{{/if}}\n```\n\n```handlebars\n{{#deferred-content gitHubRatePromise as |d|}}\n  {{#d.pending}}\n    Retrieving GitHub rate limit...\n  {{/d.pending}}\n\n  {{#d.fulfilled as |gitHubRate|}}\n    Your GitHub rate limit:\n\n    {{gitHubRate.resources.core.remaining}}\n\n    ({{multiply\n      (divide gitHubRate.resources.core.remaining gitHubRate.resources.core.limit)\n      100\n    }}%)\n  {{/d.fulfilled}}\n\n  {{#d.rejected as |reason|}}\n    Failed to retrieve GitHub rate limit.\u003cbr\u003e\n      \n    Reason: {{reason}}\u003cbr\u003e\n      \n    \u003ca href {{action 'refetchGitHubRate'}}\u003e\n      Retry\n    \u003c/a\u003e\n  {{/d.rejected}}\n{{/deferred-content}}\n```\n\nОбратите внимание, что `ember-deferred-content` вынуждает вас вычислять проценты на уровне шаблона.\n\n\n\n## Я не отговариваю вас использовать `ember-concurrency`\n\nОсновная цель этой статьи — показать вам данный прием и заставить немного задуматься. Этот прием весьма практичен, и я часто пользуюсь им в своих проектах, где не используется `ember-concurrency`.\n\nОтказаться от `ember-concurrency` в пользу `PromiseProxyMixin` можно по двум причинам:\n\n* вы считаете каждый килобайт размера вашего дистрибутива;\n* вы хотите обойтись без лишних сущностей, слоев и абстракций.\n\nЕсли же вы уже хорошо знакомы с `ember-concurrency`, и он включен в ваш проект, то использовать `PromiseProxyMixin` нет смысла. Скорее всего, код на `ember-concurrency` получится немного короче:\n\n```js\ngitHubRateTask: task(function * () {\n  return yield this._fetchGitHubRate();\n}).restartable().on('didInsertElement')\n\ngitHubRate:          reads('gitHubRateTask.last.value'),\ngitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\ngitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n\n// Если этого не сделать, запрос не будет выполнен. Императивненько. :(\ndidInsertElement () {\n  this._super()\n  this.get('fetchGitHubRateTask').perform()\n}\n```\n\nПовторяю [ссылку](https://ember-twiddle.com/bf8285db75b057eb99aea8cb0e2791ab?numColumns=2\u0026openFiles=controllers.application.js%2Ctemplates.application.hbs) на пример, выполненный на `ember-concurrency`.\n\n\n\n## Обращение к предыдущему ответу сервера, после того как повторный запрос завершился неудачей\n\nПредставьте такую ситуацию. Мы опрашиваем сервер каждую секунду, чтобы показывать актуальные данные. Мы хотим, чтобы в случае сетевого сбоя на экране продолжали отображаться последние успешно запрошенные данные.\n\n`ember-concurrency` предоставляет доступ к последним значениям resolution и rejection, если они имеются. Они остаются доступны, даже если задача перезапущена:\n\n```handlebars\n{{gitHubRateTask.lastSuccessful.value}}\n```\n\nЕсли мы поступим так же с `PromiseProxyMixin`, то значение на странице будет моргать каждую секунду. Ведь при каждом повторном запросе promise перезаписывается, и предыдущее resolution value становится недоступным.\n\nПроще всего решить проблему, добавив `.then(result =\u003e this.set('result', result))` к promise, чтобы resolution value извлекался из promise и хранился отдельно.\n\nЭто нормальное решение, но оно мне не нравится своей императивностью. Вместо этого, взгляните на такой CP макрос:\n\n```js\nfunction cachingMacro (key) {\n  let cache\n\n  return computed(key, function () {\n    const value = this.get(key)\n    \n    return value == null\n      ? cache\n      : cache = value\n  })\n}\n```\n\nЕго можно использовать так:\n\n```js\ngitHubRate:          cachingMacro('gitHubRateProxy.content'),\ngitHubRateRemaining: reads('gitHubRate.resources.core.remaining'),\ngitHubRateLimit:     reads('gitHubRate.resources.core.limit'),\n```\n\nВ результате, когда promise перезаписывается вторым promise'ом, который завершается неудачей, свойство `gitHubRate` будет по-прежнему хранить resolution value первого promise'а.\n\nНу или вы можете применить `ember-concurrency` в конце концов. :grimacing:\n\n\n\n## Что скажете?\n\nОбязательно поделитесь вашими соображениями, возражениями и идеями в комментариях внизу. Самая ценная часть любой статьи — это всегда обсуждение, которое за ней следует!\n","summary":"ember-concurrency — исключительно мощный и полезный аддон. Однако если ваш единственный юз-кейс — это обращаться к серверу, то взгляните на легковесную альтернативу","image":null,"created":"2018-01-05T00:00:00.000Z","updated":null,"hide-summary":false,"dependencies":null,"proficiency":"beginner"},"type":"posts"}}],"project-info":[],"project":[],"stackoverflow-user":[]}}</script>

    <script src="/assets/vendor-8fa103718f5228bbbf0e48134e96adcd.js" integrity="sha256-PNNj4JHm7k/vT170qeRgv+RPJpKZmN1JEiqQhed5LKg= sha512-YfbY2HN42G+vNVK15tKzxaGmwVHrPangnBAY5i38NtVF3MxdmBYx5eDd1/b5UGMbqE0CqQ6cE5LZiFKnVXvfAg==" ></script>
    <script src="/assets/lolma-us-be4b92b2e227e4641edf880f467b4f96.js" integrity="sha256-IdRe43Hzo86CxCFau0DEvc/EdTeTqKpZb4VCLtcdkyg= sha512-2oY/tj/JByJi8hKe+FV4ggaA9kOrTnE2Es6BLT3ZXKfNFCSuwdNY1pHsxewKrI4VXXVXxPr0QUdAUSDI1mOHmw==" ></script>

    
  </body>
</html>
